<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树的概念与操作]]></title>
    <url>%2F2018%2F12%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@[TOC]目录 二叉树——概念与操作基本概念二叉树的基本概念与性质 基本概念 二叉树有5种基本形态，特殊的二叉树有满二叉树、完全二叉树、二叉排序树和平衡二叉树。 性质 存储结构 二叉树的存储结构有顺序存储结构和链式存储结构两种。满二叉树和完全二叉树采取顺序存储结构比较合适，树中的节点号可以唯一的反映出节点之间的逻辑关系，可以节省空间也可以利用数组元素的下标确定节点在二叉树中的位置以及节点之间的关系。一般二叉树采用链式结构存储，二叉链表中包含3个域，分别是数据域data、左指针lchild和右指针rchild。二叉树的链式存储结构描述如下：12345// 二叉树链式存储结构typedef struct BiNode &#123; ElemType data; // 数据域 struct BiNode *lchild, *rchild; // 左右孩子指针&#125;BiNode, *BiTree; 线索二叉树的基本概念与性质 基本概念 线索二叉树的实质就是对一个非线性结构进行线性化操作，使在这个访问序列中的每一个节点都有一个直接前驱和一个直接后继，引入线索二叉树是为了加快查找节点前驱和后继的速度。 在有N个节点的二叉树中，一共有N+1空指针。在二叉树线索化的时候，通常规定：若无左子树，另lchild指向其前驱节点；若无右子树，则rchild指向其后继节点。还需要两个标志域ltag和rtag表明当前指针域所指的对象是左子节点还是直接前驱。保标志域的含义如下所示： ltag: 0 lchild域指示节点的左孩子；1 lchild域指示节点的前驱； rtag: 0 rchild域指示节点的右孩子；1 rchild域指示节点的后继。 线索二叉树的存储结构描述如下所示： 12345typedef struct ThreadNode &#123; ElemType data; // 数据域 struct ThreadNode *lchild, *rchild; // 左右孩子指针 int ltag, rtag; // 左右线索标志 &#125; ThreadNode, *TreadTree; 二叉树的操作二叉树的遍历 先序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 12345678910111213141516171819202122232425262728293031 // 递归实现先序遍历二叉树 void PreOrder(BiTree T) &#123; if (T != NULL) &#123; visit(T); PreOrder(T -&gt; lchild); PreOrder(T -&gt; rchild); &#125; &#125;/*非递归实现先序遍历二叉树 算法思路： 需要借助栈来实现，从根节点开始遍历二叉树，如果节点不为空 先输出节点的数据，节点入栈，然后指针指向节点的左孩子，如 果节点为空那么从占中弹出这个节点，并且将指针指向节点的右 孩子，重复这个过程直到栈为空，并且指针指向也为空为止。*/void PreOrder2(BiTree T) &#123; InitStack(S); BiTree p = T; while(p || !isEmpty(S)) &#123; if (p) &#123; visit(p); push(S, p); p = p -&gt; lchild; &#125; else &#123; pop(S, p); p = p -&gt; rchild; &#125; &#125;&#125;// 算法的时间复杂度和空间复杂度都是O(n) 中序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 123456789101112131415161718192021222324252627282930 // 递归算法实现中序遍历二叉树void InOrder(BiTree T) &#123; if (T != NULL) &#123; InOrder(T -&gt; lchild); visit(T); InOrder(T -&gt; rchild); &#125; &#125;/*非递归实现中序遍历二叉树 算法思路： 需要借助栈来实现，从根节点开始遍历二叉树，如果节点不为空 将节点入栈，然后指针指向节点的左孩子，如果节点为空，那么 从栈中弹出这个节点，输出节点的数据，并且将指针指向节点的 右孩子，重复这个过程直到栈为空，并且指针指向也为空为止。*/void InOrder2(BiTree T) &#123; InitStack(S); BiTree p = T; while(p || !isEmpty(S)) &#123; if (p) &#123; push(S, p); p = p -&gt; lchild; &#125; else &#123; pop(S, p); visit(p); p = p -&gt; rchild; &#125; &#125;&#125; 后序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归实现后序遍历二叉树 void PostOrder(BiTree T) &#123; if (T != NULL) &#123; PostOrder(T -&gt; lchild); PostOrder(T -&gt; rchild); visit(T); &#125; &#125;/*非递归实现后序遍历二叉树 算法思想：后序遍历先访问左节点，再访问右节点，最后访问中间节点 在访问到中间节点的时候要先弄清楚是从左节点返回的中间节点还 是从右节点返回的中间节点，所以需要一个辅助指针r指向最近访 问过的节点。*/void PostOrder2(BiTree T) &#123; InitStack(S); BiTree p, r; p = T; r = NULL; while(p || !isEmpty(S)) &#123; if (p) &#123; // 走到最左边 push(S, p); p = p -&gt; lchild; &#125; else &#123; GetTop(S, p); if (p -&gt; rchild &amp;&amp; p -&gt; rchild != r) &#123; // 如果节点的右子树存在，那么转向右边 p = p -&gt; rchild; push(S, p); p = p -&gt; lchild; // 向左走 &#125; else &#123; pop(S, p); visit(p); r = p; p = NULL; //重置指针 &#125; &#125; // else &#125; // while&#125; 层次遍历 1234567891011121314151617181920212223242526272829303132333435363738void LevelOrder(BiTree T) &#123; // 二叉树从上到下，从左到右的层次遍历需要借助队列来实现 InitQueue(Q); BiTree p = NULL; EnQueue(Q, T); // 根节点入栈； while(!isEmpty(Q)) &#123; DeQueue(Q, p); visit(p); if (p -&gt; lchild != NULL) EnQueue(p -&gt; lchild); if (p - &gt; rchild != NULL) EnQueue(p -&gt; rchild); &#125;&#125;void LevelOrderInverse(BiTree T) &#123; // 二叉树从下到上，从右到左的层次遍历 // 实现思路：将二叉树从上到下，左到右的顺序放入栈中， // 等遍历完了再弹出即可 if (T != NULL) &#123; InitStack(S); InitQueue(Q); BiTree p = t; EnQueue(Q, p); // 将根节点放入队列中 while(!isEmpty(Q)) &#123; DeQueue(Q, p); push(S, p); if (p -&gt; lchild) EnQueue(p -&gt; lchild); if (p -&gt; rchild) EnQueue(p -&gt; rchild); &#125; while(!isEmpty(S)) &#123; pop(S, p); visit(p) &#125; &#125;&#125; 由遍历序列构造二叉树（1）根据二叉树的先序和中序可以唯一的确定一棵二叉树： 假设先序和中序分别存在两个一维数组A[1….n],B[1….n]中，编写算法建立该二叉树的二叉链表。1234567891011121314151617181920212223242526/*这个算法需要遍历两个一维数组，递归实现：根据先序序列确定二叉树的根节点，根据根节点，在中序序列中划分出左子树和右子树，递归这个过程。*/BiTree PreInCreat(ElemType A[], ElemType B[], int l1, int h1, int 12, int h2) &#123; // l1,h1分别树先序序列的第一个节点和最后一个节点； // l2,h2分别树中序序列的第一个节点和最后一个节点； BiTree root = (BiNode*)malloc(sizeof(BiNode)); root -&gt; data = A[l1]; int i = 0; for (i = 0; B[i] != A[l1]; i++); // 在中序序列中找到根节点位置 int lenl = i - l2; int lenr = h2 - i; if (lenl) &#123; // 递归建立左子树 root - lchild = PreInCreat(A, B, l1 + 1, l1 + lenl, l2, l2 + lenl - 1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if (lenr) &#123; // 递归建立右子树 root - rchild = PreInCreat(A, B, h1-lenr+1, h1, h2-lenr+1, h2); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125; (2) 由二叉树的后序序列和中序序列可以唯一的确定一棵二叉树假设后序和中序分别存在两个一维数组A[1….n],B[1….n]中，编写算法建立该二叉树的二叉链表。后序序列的最后一个节点和先序序列的第一个节点类似，可以将中序分割成两个子序列。123456789101112131415161718192021222324BiTree PostInCreat(ElemType A[], ElemType B[], int l1, int h1, int l2, int h2) &#123; // l1,h1分别树后序序列的第一个节点和最后一个节点； // l2,h2分别树中序序列的第一个节点和最后一个节点; BiTree root = (BiNode*)malloc(sizeof(BiNode)); root -&gt; data = A[h1]; int i = 0; for(i = 0;B[i] != A[h1]; i++); // 在中序序列里面找到根节点 int lenl = i - l2; int lenr = h2 - i; if(lenl) &#123; root -&gt; lchild = PostInCreat(A, B, l1, l1+lenl-1, l2, l2+lenl-1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if(lenr) &#123; root -&gt; rchild = PostInCreat(A, B, h1-lenr, h1-1, h2-lenr+1, h2); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125;` (3) 由二叉树的层序序列和中序序列也可以唯一的确定一棵二叉树1234567891011121314151617181920212223242526272829303132333435// 假设层序序列和中序分别存在两个一维数组A[1....n], B[1....n]中，// 编写算法建立该二叉树的二叉链表。/* 算法思路：从左到右遍历层序数组，层序遍历的第一个元素如果在中序 中没有访问过，那么这个数可以作为根节点，根据这个根节点可以 将中序序列划分为左子树和右子树。期间需要借助一个数组来记录 元素是否在中序序列中被访问过。*/BiTree LevelInCreat(ElemType A[], ElemType B[], boolean C[], int index, int l, int r) &#123;/* 初始时C是一个全为真的布尔数组，大小与A,B相同，如果C中元素在 B中被访问过，那么标记为假，此时A中对应的被访问到的元素就不能 作为根节点，需要继续往右寻找没有被访问过的节点作为根节点。*/ BiTree root = (BiNode*)malloc(sizeof(BiNode)); for(index; C[index] == false; index++); // 排除已经访问过的节点的干扰 root -&gt; data = A[index]; int i = 0; for(i = 0; B[i] != A[index]; i++); C[index] = false; // 已经访问过的节点就标记为已访问 int lenl = i - l; int lenr = r - i; if (lenl) &#123; root -&gt; lchild = LevelInCreat(A, B, C, index+1, l, l+lenl-1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if(lenr) &#123; root -&gt; lchild = LevelInCreat(A, B, C, index+1, r-lenr+1, r); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125; 一些二叉树的题目 （1）判断二叉树是否为完全二叉树 思路：使用层次遍历算法，将所有节点加入队列，包括空节点，遍历结束 后查看队列，如果遇到了空节点，看看其后是否有非空节点，如果有，那 么二叉树不是完全二叉树，否则是完全二叉树。 （2）链式存储，计算二叉树的所有双分支节点的个数 思路：采用如下所示的递归式： f(b) = 0; 若b = NULL f(b) = f(b-&gt;lchild) + f(b-&gt;rchild) + 1; 若b为双分支节点 f(b) = f(b-&gt;lchild) + f(b-&gt;rchild); 其余情况 （3）交换二叉树中所有节点的左右子树 swap(b-&gt;lchild) 递归交换左子树 swap(b-&gt;rchild) 递归交换右子树 交换左右孩子节点 （4）指针p,q分别指向二叉树的任意两个节点，寻找p,q的最近的公共祖先节点。 采用后序遍历，访问到其中一个节点之后将其之后的所有祖先节点放 入一个队列中，另一个节点也是一样，访问到之后将其所有祖先节点 放入另一个队列中，遍历结束之后，比较两个队列，两个队列第一个 相同的元素就是两个节点的最近公共祖先节点。 （5）链式存储，求非空二叉树的宽度 采用层次遍历即可得出 （6）满二叉树已知先序序列pre，求后序序列post. 先序序列的第一个节点为后序序列的最后一个节点，然后除第一个元 素之外，将先序序列划分为大小相等的两份，再对这两份转化。 void PreToPost(pre, post, int l1, int h1, int l2, int h2) { if(h1 &gt;= l1) { post[h2] = pre[l1]; half = (h1-l1) / 2; PreToPost(pre, post, l1+1, l1+half, l2, l2+half-1); PreToPost(pre, post, l1+half+1, h1, l2+half, h2-1); } }]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树与森林]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[@TOC 树和森林树的基本概念与性质 基本概念 树的定义是递归的，树是一种逻辑结构，同时也是一种分层结构。 性质 （1）树中的节点数等于所有节点的度数加1； （2）度为m的树中第i层上至多有m^(i-1)个节点； （3）高度为h的m叉树至多有(m^h - 1)/(m-1)个节点； （4）具有n个节点的m叉树的最小高度为[logm(n(m-1)+1)] 树的存储结构 （1）双亲表示法 采用一组连续的空间存储每个节点，同时在每个节点中增设一个伪指针，指示这个节点的双亲节点在数组中的位置，利用这种存储结构可以很快的得到每一个节点的双亲节点，但是求节点的孩子节点时需要遍历整个结构。 （2）孩子表示法 每个节点的孩子节点都用一个单链表链接起来形成一个线性结构，那么N个节点就有N个孩子链表。 （3）孩子兄弟表示法 又称为二叉树表示法，即以二叉链表作为树的存储结构，使得每个节点包括三个内容：节点值、指向节点第一个孩子节点的指针和指向节点下一个兄弟节点的指针。 树和森林的操作树和森林的应用]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的概念与操作]]></title>
    <url>%2F2018%2F12%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC 二叉树——应用二叉排序树（BST） 二叉排序树的定义 或者是一棵空树，或者有如下性质的树： （1）若左子树非空，则左子树上所有节点关键字值均小于根节点的关键字值；（2）若右子树非空，则右子树上所有节点关键字值均大于根节点的关键字值；（3）左右子树也分别是一颗二叉排序树。因此，对二叉排序树的中序遍历得到的就是一个递增的序列。 二叉排序树的查找 从根节点开始，沿一个分支逐层向下进行比较的过程。若二叉树非空，将给定的关键字与根节点的值比较，如果相同则查找成功，如果不相同，如果给定的关键字的值大于根节点的值那么转向右子树寻找，如果小于则向左子树寻找。 算法表示如下所示： 1234567891011121314151617181920212223242526BSTNode* BST_Search(BiTree T, ElemType key, BSTNode *p) &#123; // 查找函数返回指向关键字值为key的节点指针，如果不存在， // 返回NULL // p指向被查找节点的双亲节点 p = NULL; while(T &amp;&amp; key != T-&gt;data) &#123; p = T; if (key &lt; T -&gt; data) T = T -&gt; lchild; else T = T -&gt; rchild; &#125; return T;&#125;BSTNode* BST_RecurSearch(BiTree T, ElemType key, BSTNode *p) &#123; // 算法的递归实现形式 if (T) &#123; if (key == T -&gt; data) return T; else if (key &lt; T -&gt; data) BST_RecurSearch(T -&gt; lchild, key, T) else BST_RecurSearch(T -&gt; rchild, key, T) &#125;&#125; 二叉排序树的插入在查找的过程中，如果没有查找到关键字值的二叉树时，将节点插入到二叉树中，如果二叉树原本为空则要插入的节点为根节点，如果要插入的值比根节点的值大则插入到右子树中，如果比根节点的值小，则插入到左子树中。 算法如下所示： 12345678910111213141516int BST_Insert(BiTree &amp;T, ElemType key) &#123; // 如果二叉树中存在值为key的节点，那么返回0； // 如果二叉树中不存在值为key的节点，那么插入节点并返回1； if (T == NULL) &#123; T = (BSTNode*)malloc(sizeof(BSTNode)); T -&gt; data = key; T -&gt; lchild = T -&gt; rchild = NULL; return 1; &#125; else if (T -&gt; data == key) &#123; return 0; &#125; else if (key &lt; T -&gt; data) &#123; BST_Insert(T -&gt; lchild, key); &#125; else &#123; BST_Insert(T -&gt; rchild, key); &#125;&#125; 二叉排序树的构造 依次输入数据元素，并且将它们插入到排序树中适当的位置。具体过程是每读入一个元素就建立一个新节点，若二叉树为空则这个节点为根节点，如果二叉树不为空的话，则将这个节点插入二叉树中。 算法如下所示： 12345678void BST_Creat(BiTree &amp;T, ElemType str[], int n) &#123; T == NULL; int i = 0; while(i &lt; n) &#123; BST_Insert(T, str[i]); i++; &#125;&#125; 二叉排序树的删除 删除二叉树节点的过程按照三种情况来处理： （1）如果被删除节点是叶子结点，则直接删除，不会破坏二叉排序树的性质； （2）如果节点只有一颗左子树或者右子树，则让节点的子树称为节点父节点的子树，代替被删除节点的位置； （3）如果被删除节点有左右子树的话，则在右子树中找中序第一个子女填补。 算法表示如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void BST_Delete(BiTree T, ElemType key) &#123; BiTree pre = NULL; BiTree p = BST_Search(T, key, pre); // 查找节点 if (p == NULL) return; if (p -&gt; lchild == NULL &amp;&amp; p -&gt; rchild == NULL) &#123; // 如果是叶子节点则直接删除； if (pre -&gt; lchild == p) pre -&gt; lchild = NULL; else if (pre -&gt; rchild == p) pre -&gt; rchild = NULL; free(p) &#125; else if (p -&gt; lchild == NULL &amp;&amp; p -&gt; rchild != NULL) &#123; // 左子树为空 if (pre -&gt; lchild == p) pre -&gt; lchild = p -&gt; rchild; else if (pre -&gt; rchild == p) pre -&gt; lchild == p -&gt; rchild; free(p) &#125; else if (p -&gt; lchild != NULL &amp;&amp; p -&gt; rchild == NULL) &#123; // 右子树为空 if (pre -&gt; lchild == p) pre -&gt; lchild == p -&gt; lchild; else if (pre -&gt; rchild == p) pre -&gt; rchild = p -&gt; lchild; free(p); &#125; else &#123; // 左右子树都不为空 // 寻找右子树在中序遍历的情况下第一个输出的节点； BiTree temp = p -&gt; rchild; Bitree pre2 = p; while (temp -&gt; lchild != NULL) &#123; temp = temp -&gt; lchild; pre2 = p; &#125; p -&gt; data = temp -&gt; data; // 删除temp节点； if (pre2 -&gt; lchild == temp) pre2 -&gt; lchild == temp -&gt; rchild; if (pre2 -&gt; rchild == temp) pre2 -&gt; rchild == temp -&gt; rchild; free(temp); &#125;&#125; 二叉平衡树（AVL） 平衡二叉树的定义 在插入和删除节点的时候，保证任意节点的左右子树的高度差不超过1，这样的二叉树称为平衡二叉树，简称平衡树。定义左子树和右子树的高度差为平衡因子，则平衡因子的值只可能为-1， 0， 1三种。 所以平衡二叉树可定义为它或者是一颗空树，或者它的左右子树都是平衡二叉树，并且左右子树的高度差不超过1. 平衡二叉树的插入 按照二叉排序树插入节点的规则向二叉树中插入一个节点，插入之后，如果二叉树不再是平衡二叉树那么调整二叉树，使得这个二叉树成为新的平衡二叉树。 失去平衡之后调整可归纳为一下四种情况： （1）LL平衡旋转：在A节点的左孩子（L）的左子树（L）上插入了新节点，导致A的平衡因子从1变成了2，导致以A为根的子树失去平衡，需要一次向右旋转的操作。使得A的左孩子接替A，而A的左孩子的右子节点称为旋转后的A的左孩子节点。 （2）RR平衡旋转：由于在A节点的右孩子（R）的右子树（R）上插入了新的节点，导致A的平衡因子从-1变成了-2，失去平衡。需要一次向左旋转的操作。 （3）LR平衡旋转：在A节点的左孩子（L）的右子树（R）上插入了新节点，导致A的平衡因子从1变成了2，导致以A为根的子树失去平衡，需要两次旋转，先向左旋转，再向右旋转。 （4）RL平衡旋转：在A节点的右孩子（R）的左子树（L）上插入了新节点，导致A的平衡因子从-1变成了-2，导致以A为根的子树失去平衡，需要两次旋转，先右旋转，再左旋转。 平衡二叉树的查找 查找过程与二叉排序树相同。 关于平衡二叉树的具体实现C++程序，可以参考平衡二叉树详解（本地测试过了，程序可以运行） 哈夫曼树与哈弗曼编码 哈夫曼树的定义 在含有N个带权叶子结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也成为最优二叉树。 哈夫曼树的构造 给定N个权值分别为w1, w2, …, Wn的节点。构造哈夫曼树的算法描述如下： （1）将这N个结点分别作为N棵树仅含一个结点的二叉树，构成森林F. （2）构造一个新节点，并从F中选取两棵根结点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根结点的权 值之和。 （3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 （4）重复步骤2和3，直至F中只剩下一棵树为止。 哈弗曼编码 哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码，它是可变长度编码。可变长编码即可以对待处理字符串中不同字符使用不等长的二进制位表示，可变长编码比固定长度编码好很多，可以对频率高的字符赋予短编码，而对频率较低的字符则赋予较长一些的编码，从而可以使平均编码长度减短，起到压缩数据的效果。 哈夫曼编码是前缀编码。如果没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。对前缀编码的解码也是相对简单的，因为没有一个码是另一个编码的前缀，所以可以识别出第一个编码，将它翻译为原码，再对余下的编码文件重复同样操作。 哈夫曼编码首先要构造一棵哈夫曼树，首先，将每个出现的字符当做一个独立的结点，其权值作为它出现的频度（或次数），然后构造哈夫曼树。显然所有字符节点均出现在叶子结点中。我们可以将字符的编码解释为从根至该字符路径上标记的序列，其中标记为0表示”转向左孩子”，标记为1表示为”转向右孩子”。 部分题目算法编写 判断一棵二叉树是否是二叉排序树。 123456789101112131415161718// 方案1：直接在二叉树中比较 bool isBST_Tree(BiTree T) &#123; if (T) &#123; // 左子值大于根节点值 if (T -&gt; lchild &amp;&amp; T -&gt; lchild -&gt; data &gt; T -&gt; data) return false; // 右子值小于根节点值 if (T -&gt; rchild &amp;&amp; T -&gt; rchild -&gt; data &lt; T -&gt; data) return false; // 不存在左右节点 if (T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL) return true; else return isBST_Tree(T -&gt; lchild) &amp;&amp; isBST_Tree(T -&gt; rchild); &#125; &#125; // 方案2：中序遍历二叉树，得到的结果始终满足前一个元素的数据小于后一个元素的数据。 利用二叉树的遍历思想，判断一棵二叉树是否为平衡二叉树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 void Judge_AVL(BiTree T, int &amp;balance, int &amp;h) &#123; // 左右子树的平衡标记和高度 int bl = 0, br = 0, hl = 0, hr = 0; if (T == NULL) &#123; h = 0; balance = 1; &#125; else if (T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL) &#123; h = 1; balance = 1; &#125; else &#123; Judge_AVL(T -&gt; lchild, bl, hl); Judge_AVL(T -&gt; rchild, br, hr); int h = (hl&gt;hr?hl:hr) + 1; if (abs(h) &lt; 2) balance = bl &amp;&amp; br; else balance = 0; &#125; &#125; ``` 3. 设计一个算法，从大到小输出二叉排序树中所有其值不小于k的关键字。 ```C++ void printk(BiTree T, int k) &#123; if (T) &#123; if (T -&gt; data &gt; k) &#123; printk(T -&gt; rchild, k); cout &lt;&lt; T -&gt; data &lt;&lt; " "; printk(T -&gt; lchild, k); &#125; else if (T -&gt; data == k)&#123; cout &lt;&lt; k &lt;&lt; " "; return; &#125; else &#123; return; &#125; &#125; &#125; // 以下的是一个更为简洁的函数； void Printk(BiTree T, int k) &#123; if (T == NULL) return; if (T -&gt; rchild != NULL) Printk(T -&gt; rchild, k); if (T -&gt; data &gt;= k) cout &lt;&lt; T-&gt; data &lt;&lt; " "; if (T -&gt; lchild != NULL) Printk(t -&gt; lchild, k); &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
