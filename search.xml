<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F30%2F%E7%8E%8B%E9%81%93%E6%9C%BA%E8%80%83%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[@TOC 王道论坛机考系列——图论并查集]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F28%2F%E7%8E%8B%E9%81%93%E6%9C%BA%E8%80%83%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[@TOC 数学问题% 运算符数位拆解进制转换 输入两个不超过整形定义的非负10进制整数A和B，输出A+B的m进制数。$$ A, B &lt;= 2^{23} - 1$$ 输入样例： 样例输出： 8 1300 48 2504 2 1 7 1000 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;void TenToM(long data, int m, int arr[], int &amp;len) &#123; // 十进制到m进制的转换 long long temp = data; len = 0; while (temp) &#123; arr[len] = temp % m; temp = temp / m; len++; &#125;&#125;void AddM(int m, int arr1[], int arr2[], int arr[], int l1, int l2, int &amp;l) &#123; // m进制的两个数相加 int len = l1 &lt; l2 ? l1 : l2; l = l1 &lt; l2 ? l2 : l1; int index = 0; int add = 0; for (int i = 0; i &lt; len; i++) &#123; add = arr1[i] + arr2[i] + index; if (add &gt;= m) &#123; index = 1; add = add % m; &#125; else &#123; index = 0; &#125; arr[i] = add; &#125; if (l1 &lt; l2) &#123; for(int i = len; i &lt; l2; i++) &#123; add = arr2[i] + index; if (add &gt;= m) &#123; index = 1; add = add % m; &#125; else &#123; index = 0; &#125; arr[i] = add; &#125; &#125; else if (l1 &gt; l2) &#123; for(int i = len; i &lt; l1; i++) &#123; add = arr1[i] + index; if (add &gt;= m) &#123; index = 1; add = add % m; &#125; else &#123; index = 0; &#125; arr[i] = add; &#125; &#125; if (index == 1) &#123; arr[l] = 1; l += 1; &#125;&#125;int main() &#123; int m; long long A, B; while(scanf("%d%lld%lld", &amp;m, &amp;A, &amp;B) == 3) &#123; int arrA[32] = &#123;0&#125;; int arrB[32] = &#123;0&#125;; int ans[33] = &#123;0&#125;; int lena = 0; int lenb = 0; int lenans = 0; TenToM(A, m, arrA, lena); TenToM(B, m, arrB, lenb); AddM(m, arrA, arrB, ans, lena, lenb, lenans); for(int i = lenans - 1; i &gt;= 0; i--) &#123; printf("%d", ans[i]); &#125; printf("\n"); &#125; return 0;&#125; 最大公约数题目：求两个正整数的最大公约数 输入：两个正整数； 输出：最大公约数。 12345678910111213141516#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int GCD(int a, int b) &#123; if (b == 0) return a; return GCD(b, a % b);&#125;int main() &#123; int a, b; while(scanf("%d%d", &amp;a, &amp;b) != EOF) &#123; printf("%d\n", GCD(a, b)); &#125; return 0;&#125; 最小公倍数最小公倍数的等于两个数的乘积除以他们的最大公约数。 1234567891011121314#include &lt;iostream&gt;using namespace std;int GCD(int a, int b) &#123; return b != 0 ? GCD(b, a % b) : a;&#125;int main() &#123; int a, b; while(scanf("%d%d", &amp;a, &amp;b) != EOF) &#123; printf("%d\n", a * b / GCD(a, b)); &#125; return 0;&#125; 素数判定 输入一个数，判断这个数是否是素数。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;bool IsPrim(int n) &#123; // 0 1 负数都是非素数 if (n &lt; 2) return false; int index = (int)sqrt(n) + 1; for (int i = 2; i &lt; index; i++) if (n % i == 0) return false; return true;&#125;int main() &#123; int a; while(scanf("%d", &amp;a) != EOF) &#123; if (IsPrim(a)) printf("yes\n"); else printf("no\n"); &#125; return 0;&#125; 求解素数给定一个数，给出这个数范围内的所有素数，并输出，最后一个数后面没有空格。 思路：从2开始，当遍历到一个数的时候将所有这个数的倍数标记为非素数，所以当我们遍历到某个数的时候如果它没有被比它小的数标记为非素数的话它就是素数。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int prime[10000]; // 保存找出的素数int primenum = 0; // 保存找出的素数的个数bool mark[10000] = &#123;false&#125;;void init() &#123; // 找出所有小于10001的素数 for (int i = 2; i &lt;= 10000; i++) &#123; if (mark[i] == false) &#123; prime[primenum++] = i; // 从i*i开始标记是因为比i*i小的数据都在之前就有标记过了。 for (int j = i * i; j &lt;= 10000; j += i) mark[j] = true; &#125; &#125;&#125;int main() &#123; int a; init(); while(scanf("%d", &amp;a) != EOF) &#123; bool isoutput = false; for (int i = 0; i &lt; primenum; i++) &#123; if (prime[i] &lt;= a) &#123; if (isoutput == false) &#123; printf("%d", prime[i]); isoutput = true; &#125; else &#123; printf(" %d", prime[i]); &#125; &#125; else &#123; break; &#125; &#125; &#125; return 0;&#125; 分解素因数求解质因数给定一个数，求这个这个数的质因数的个数。 输入： 120（120 = 2 * 2 * 2 * 3 * 5）; 输出： 5 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;long prime[100000];long primenum = 0;bool mark[100000] = &#123;false&#125;;void init() &#123; for (long i = 2; i &lt; 100000; i++) &#123; if (mark[i] == false) &#123; prime[primenum++] = i; if (i &gt;= 1000) continue; for (long j = i * i; j &lt; 100000; j += i) mark[j] = true; &#125; &#125;&#125;int main() &#123; int a; init(); while(scanf("%d", &amp;a) != EOF) &#123; int n = a; int num = 0; for (int i = 0; i &lt; primenum; i++) &#123; if (n % prime[i] == 0) &#123; num++; n = n / prime[i]; while(n % prime[i] == 0) &#123; num++; n = n / prime[i]; &#125; &#125; if (n == 1) break; &#125; if (n != 1) &#123; num++; &#125; printf("%d\n", num); &#125; return 0;&#125; 整除问题 给定n, a求最大的k，使得n！可以被a^k整除但不能被a^(k+1)整除。 输入：两个整数n, a.（2 &lt;= n &lt;= 1000, 2 &lt;= a &lt;= 1000）. 输出：一个整数。 样例输入：6 10 样例输出：1 **分析：** 由于n!和 a^k数字会变得很大，甚至long long数据类型都无法保存，所以不能暴力计算出值之后再求k，其中一个可以采用的方法就是质因数分解，将n!和a^k都进行质因数分解，再对分解的结果进行计算就好，n!和a^k的质因数分解结果如下所示： $$ b = p1^{e1} p2^{e2} p3^{e3}....pn^{en} $$ $$ a = p1&apos;^{e1&apos;} p2&apos;^{e2&apos;} p3&apos;^{e3&apos;}....pn&apos;^{en&apos;} $$ $$ a^{k} = p1&apos;^{ke1&apos;} p2&apos;^{ke2&apos;} p3&apos;^{ke3&apos;}....pn&apos;^{ken&apos;} $$ 要想a能被b整除，那么a中存在的质因数p在b中也必然存在，并且a中的幂指数必定不大于b中的p的幂指数。 现在令x = n!, y = a^k，则 $$ x = p1^{e1} p2^{e2} p3^{e3}....pn^{en} $$ $$ y = p1&apos;^{ke1&apos;} p2&apos;^{ke2&apos;} p3&apos;^{ke3&apos;}....pn&apos;^{ken&apos;} $$ 现在要确定k使得y中的任一素因数的幂指数的k倍依旧小于或等于x中的幂指数，要求得k只需要一次测试a中的每一个素因数就可以了。 所以，现在问题转化为求n!和a^k的素因数的问题了，a^k的素因数比较容易，求出a的素因数就很容易了，关键是n!的素因数，n！是从1到n的数字的乘积，这些乘积中，每一个素因数p的倍数都将为n！至少贡献一个素因子，则p至少提供n/p个素因子，每一个p * p都将为n!至少贡献两个素因子，则至少为n!贡献n / (p * p)个素因子，p*p*p同理。 下面以10!为例来简单展示以上讨论： $$ 10! = 10 9 8 7 6 5 4 3 2 $$ 10以内的素因数有：2 3 5 7这四个。 2 为 10! 提供 10 / 2 = 5 个素因数， 2 2 为10!提供 10 / (2 2) = 2，个素因数，所以2提供5 + 2个素因数。这7个素因数分别来自 2、4、6、8、10，其中2里1个，4里2个，6里1个，8里3个，10里1个。 同理可对3、5、7进行计算。 这样就将原本计算n!的素因数的数学计算转化为了计算1 ~ n的素因数的问题了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define NUM 1001int prime[NUM] = &#123;0&#125;; // 存储2-NUM的素因数。int primenum = 0; // 记录NUM以内的所有素数的个数int primen[NUM] = &#123;0&#125;; // 存储n的所有素因数int primea[NUM] = &#123;0&#125;; // 存储a的所有素因数int numn[NUM] = &#123;0&#125;; // 存储n!的每一个素因数的个数int numa[NUM] = &#123;0&#125;; // 存储a的每一个素因数的个数bool mark[NUM] = &#123;false&#125;;void init() &#123;// 将NUM以内的所有素因数存储起来。 int index = (int)sqrt(NUM) + 1; for (int i = 2; i &lt; NUM; i++) &#123; if (mark[i] == false) &#123; prime[primenum++] = i; // 记录下素数 if (i &gt; index) continue; for (int j = i * i; j &lt; NUM; j += i) //将所有i的倍数标记为非素数 mark[j] = true; &#125; &#125;&#125;void Primen(int n, int &amp;len) &#123; // 计算n!的素数 for (int i = 0; i &lt; NUM; i++) &#123; primen[i] = 0; numn[i] = 0; &#125; int p = 0; int index = 0; int temp = n; for (int i = 0; i &lt; primenum; i++) &#123; p = prime[i]; temp = n; if (temp / p &gt; 0) &#123; while(temp) &#123; primen[index] = p; // 记录下素数 numn[index] += temp / p; temp = temp / p; &#125; index++; &#125; &#125; len = index;&#125;void Primea(int a, int &amp;len) &#123; for (int i = 0; i &lt; NUM; i++) &#123; // 先将计数器清零 numa[i] = 0; primea[i] = 0; &#125; int temp = a; int p = 0; int index = 0; for (int i = 0; i &lt; NUM; i++) &#123; p = prime[i]; if (temp % p == 0) &#123; while(temp % p == 0) &#123; primea[index] = p; numa[index]++; temp = temp / p; &#125; index++; &#125; if (temp == 1) break; &#125; len = index;&#125;int Findk(int ln, int la) &#123; int temp = 0, index = 0; for (int k = 0; ;k++) &#123; for (int i = 0; i &lt; la; i++) &#123; // 确保a的质因数都在n!的质因数中，如果不在，则返回0 temp = numa[i] * k; for (index = 0; index &lt; ln, primea[i] != primen[index]; index++); if (index &gt;= ln) return 0; if (numn[index] &lt; temp) return k - 1; &#125; &#125;&#125;int main() &#123; int n; int a; init(); // 先初始化，找出1001以内的所有素数 while(scanf("%d%d", &amp;n, &amp;a) != EOF) &#123; int lenn = 0; int lena = 0; int k = 0; int temp = 0; Primen(n, lenn); // 计算n!的素因数分解 Primea(a, lena); // 计算a的素因数分解 printf("%d\n", Findk(lenn, lena)); &#125; return 0;&#125; 二分求幂题目描述：求A^B的最后三位数表示的整数(A^B表示A的B次方)。 A 与 B均为0，即结束。 样例输入： 样例输出： 2 3 8 12 6 984 6789 10000 1 0 0 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main() &#123; int a, b; while(scanf("%d%d", &amp;a, &amp;b) != EOF) &#123; if (a == 0 &amp;&amp; b == 0) break; int ans = 1; while(b) &#123; if (b % 2 == 1) &#123; ans *= a; ans = ans % 1000; // 因为题目只要求保留后三位数字 &#125; b = b / 2; a *= a; a = a % 1000; &#125; printf("%d\n", ans); &#125; return 0;&#125; 上面介绍的二分求幂的方法其实就是把幂指数进行二分分解使用二进制来表示幂指数，例如：$$12^{6} = 12^{2^{2}}12^{2^{1}}, 6的二进制表示是1010 只需要在两个1的位置完成计算即可$$ 以12^6为例，解释循环中的操作： 循环次数 ans的值 b的值 a的值 0 1 6 12 1 1 3 12^2 2 112^2 1 12^2 12^2 3 112^212^212^2 0 (12^2*12^2)^2 如果以正常的循环来求的话要求6次，6个循环才能求出12^6的值，但是使用二分求幂，只需要4次循环，当幂指数变得很大的时候这种做法可以节约一半的时间。 高精度整数高精度整数数值非常巨大，无法使用计算机的内置数据类型来保存它的值，所以只能使用结构体来存储，高精度整数的内置类型如下所示：1234567struct BigInteger &#123; int digit[1000]; int size; // 每四位使用一个存储单元，例如整数123456789，存出结果为 // digit[0] = 6789, digit[1] = 2345, digit[2] = 1; // size = 3；&#125;; 高精度加法题目： 实现一个加法器，使其能够输出a+b的值 输入：两个数a和b，每个数不超过1000位 输出：可能有多组测试数据，对每组数据输出a+b的值 样例输入： 2 6 10000000000000000000 1000000000000000000000000000000000 样例输出： 8 1000000000000010000000000000000000 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct BigInteger &#123; int digit[1000]; int size; void Init() &#123; size = 0; for (int i = 0; i &lt; size; i++) digit[i] = 0; &#125; void Set(char str[]) &#123; // 将输入的字符串转化为整数存储在digit中 Init(); int len = strlen(str); int index = 0; // 计数，每四位数记录一次 int num = 0; // 记录转换过程中的数字 int tenq = 1; // 权重 for (int i = len - 1; i &gt;= 0; i--) &#123; num += (str[i] - '0') * tenq; tenq *= 10; index++; if (index == 4 || i == 0) &#123; digit[size++] = num; num = 0; tenq = 1; index = 0; &#125; &#125; &#125; void Ouput() &#123; // 将运算后的结果用字符串输出出来。 for (int i = size - 1; i &gt;= 0; i--) &#123; if (i != size - 1) printf("%04d ", digit[i]); else printf("%d ", digit[i]); // 如果不是最高位，那么不足4位时，用0补足，例如110001在digit中的存储为 // digit[0] = 1, digit[1] = 11, 由于0001在实际存储时会变为1， // 所以需要补足0； &#125; &#125; BigInteger operator + (const BigInteger &amp;A) const &#123; // 加法运算符； BigInteger ret; ret.Init(); int carry = 0; int add = 0; for (int i = 0; i &lt; size || i &lt; A.size; i++) &#123; // 完成相同长度下的加法运算 add = digit[i] + A.digit[i] + carry; carry = add / 10000; ret.digit[i] = add % 10000; ret.size++; &#125; if (carry) &#123; // 有进位则进1 ret.digit[size] = carry; ret.size++; &#125; return ret; &#125;&#125;;int main() &#123; char A[1000], B[1000]; while(scanf("%s %s", A, B) != EOF) &#123; BigInteger BigA, BigB, BigC; BigA.Set(A); BigB.Set(B); BigC = BigA + BigB; BigC.Ouput(); printf("\n"); &#125; return 0;&#125; N的阶乘题目描述：输入一个数N，输出N的阶乘。 输入：正整数N（0 &lt;= N &lt;= 1000） 输出：有可能有多组输入，对于每一组输入，输出N! 样例输入： 4 5 15 样例输出： 24 120 1307674368000 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct BigInteger &#123; int digit[1000]; int size; void Init() &#123; size = 0; for (int i = 0; i &lt; size; i++) digit[i] = 0; &#125; void Set(int x) &#123; // 将输入的字符串转化为整数存储在digit中 Init(); do &#123; digit[size++] = x % 10000; x = x / 10000; &#125; while(x); // 使用 do-while循环是要确保x等于0时也能被处理 &#125; void Ouput() &#123; // 将运算后的结果用字符串输出出来。 for (int i = size - 1; i &gt;= 0; i--) &#123; if (i != size - 1) printf("%04d", digit[i]); else printf("%d", digit[i]); // 如果不是最高位，那么不足4位时，用0补足，例如110001在digit中的存储为 // digit[0] = 1, digit[1] = 11, 由于0001在实际存储时会变为1， // 所以需要补足0； &#125; &#125; BigInteger operator * (const int x) const &#123; // 乘法运算符； BigInteger ret; ret.Init(); int carry = 0; int pro = 0; for (int i = 0; i &lt; size; i++) &#123; pro = digit[i] * x + carry; ret.digit[i] = pro % 10000; carry = pro / 10000; &#125; ret.size = size; // 进位这里需要注意，曾经因为将进位设置为1而出错，进位不一定为1 if(carry) ret.digit[ret.size++] = carry; return ret; &#125;&#125;;int main() &#123; int n; while(scanf("%d", &amp;n) != EOF) &#123; BigInteger A; A.Init(); A.Set(n); for (int i = 2; i &lt; n; i++) A = A * i; A.Ouput(); printf("\n"); &#125; return 0;&#125; 进制转换题目描述：将M进制数转换为N进制数。 输入：输入的第一行包括两个整数：M和N (2 &lt;= M, N &lt;= 30); 输入的下一行是一个数X，数是M进制数，将其转化为N进制数，注意X的输入是一个字符串； 输出： 输出X的N进制数。 样例输入： 16 10 F 样例输出： 15 提示：输入时字母部分为大写，输出时转化为小写，可能有大数据。 思路： 将M进制数转化为10进制数，再将10进制数转化为N进制数。 `C++ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAXSIZE 100 struct BigInteger { int digit[1000]; int size; void Init() { size = 0; for (int i = 0; i &lt; size; i++) digit[i] = 0; } void Set(int x) { // 将输入的字符串转化为整数存储在digit中 Init(); do { digit[size++] = x % 10000; x = x / 10000; } while(x); // 使用 do-while循环是要确保x等于0时也能被处理 } void Ouput() { // 将运算后的结果用字符串输出出来。 for (int i = size - 1; i &gt;= 0; i--) { if (i != size - 1) printf(&quot;%04d&quot;, digit[i]); else printf(&quot;%d&quot;, digit[i]); // 如果不是最高位，那么不足4位时，用0补足，例如110001在digit中的存储为 // digit[0] = 1, digit[1] = 11, 由于0001在实际存储时会变为1， // 所以需要补足0； } } BigInteger operator + (const BigInteger &amp;A) const { // 加法运算符； BigInteger ret; ret.Init(); int carry = 0; int add = 0; for (int i = 0; i &lt; size || i &lt; A.size; i++) { // 完成相同长度下的加法运算 add = digit[i] + A.digit[i] + carry; carry = add / 10000; ret.digit[i] = add % 10000; ret.size++; } if (carry) { // 有进位则进1 ret.digit[size] = carry; ret.size++; } return ret; } BigInteger operator * (const int x) const { // 加法运算符； BigInteger ret; ret.Init(); int carry = 0; int pro = 0; for (int i = 0; i &lt; size; i++) { pro = digit[i] * x + carry; ret.digit[i] = pro % 10000; carry = pro / 10000; } ret.size = size; if(carry) ret.digit[ret.size++] = carry; return ret; } BigInteger operator / (const int x) const { BigInteger ret; ret.Init(); int divide = 0; // 保存除数 int reminder = 0; // 保存余数 for (int i = size - 1; i &gt;= 0; i--) { divide = (reminder * 10000 + digit[i]) / x; reminder = (reminder * 10000 + digit[i]) % x; ret.digit[i] = divide; } for (int i = 0; i &lt; MAXSIZE; i++) if(ret.digit[i] != 0) ret.size = i; ret.size++; return ret; } int operator % (int x) const { int reminder = 0; int divide = 0; for (int i = size - 1; i &gt;= 0; i--) { divide = (reminder * 10000 + digit[i]) / x; reminder = (reminder * 10000 + digit[i]) % x; } return reminder; } }; int main() { int m, n; char str[1000]; // 输入的需要转化的数字 char ans[1000]; // 转化后的n进制数 while(scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) { BigInteger BigA; // 存储m转化为10进制后的数字 BigInteger BigB; // 存储计算过程中的权重信息 BigA.Set(0); BigB.Set(1); scanf(&quot;%s&quot;, str); int len = strlen(str); int digit; for(int i = len - 1; i &gt;= 0; i--) { if(str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;) { digit = str[i] - &apos;0&apos;; } else { digit = str[i] - &apos;A&apos; + 10; } BigA = BigA + BigB * digit; BigB = BigB * m; } int index = 0; int divide = 0; int reminder = 0; do { reminder = BigA % n; BigA = BigA / 10; if (reminder &gt;= 10) ans[index++] = reminder - 10 + &apos;a&apos;; else ans[index++] = reminder + &apos;0&apos;; } while(BigA.digit[0] != 0 || BigA.size != 1); for (int i = index - 1; i &gt;= 0; i--) printf(&quot;%c&quot;, ans[i]); printf(&quot;\n&quot;); } return 0; }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F28%2F%E7%8E%8B%E9%81%93%E6%9C%BA%E8%80%83%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[@TOC 第三章 数据结构栈例1. 括号匹配 例2. 计算简单表达式 哈夫曼树 哈夫曼树的定义 在含有N个带权叶子结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也成为最优二叉树。 构造哈夫曼树的算法描述如下： 给定N个权值分别为w1, w2, …, Wn的节点。 （1）将这N个结点分别作为N棵树仅含一个结点的二叉树，构成森林F. （2）构造一个新节点，并从F中选取两棵根结点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根结点的权值之和。 （3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 （4）重复步骤2和3，直至F中只剩下一棵树为止。 在构造哈夫曼树的过程中使用小根堆可以在O(logn)的时间内取得n个元素中最小的数。借助STL中的优先队列，利用如下语句：12345678// 定义一个小根堆：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; Q;// 元素入队Q.push(x;)// 取堆顶元素int a = Q.top();// 元素出堆Q.pop(); 例3： 题目描述：哈夫曼树，第一行输入一个数n，表示叶节点的个数。需要用这些叶节点生成哈夫曼树，根据哈夫曼树的概念，这些节点有权值，即 weight，题目需要计算出所有节点与权值的乘积之和。 输入有多组数据： 第一行数据n； 第二行有n个数据 样例输入： 5 1 2 2 5 9 样例输出： 37 C++实现：12345678910111213141516171819202122232425262728293031323334#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;int main() &#123; int n; while(scanf("%d", &amp;n) != EOF) &#123; while(!Q.empty()) Q.pop(); // 排除堆非空对题目的影响 int m = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;m); Q.push(m); &#125; int ans = 0; while(Q.size() &gt; 1) &#123; int a = Q.top(); Q.pop(); int b = Q.top(); Q.pop(); ans += a + b; Q.push(a + b); // push这里每一层叠加的时候就把权值也计算进去了 &#125; printf("%d", ans); &#125; return 0;&#125; 二叉树二叉树节点的数据结构：12345struct TNode &#123; struct TNode* lchild; // 左孩子 struct TNode* rchild; // 右孩子 ElemType data; // 数据域&#125; TNode, *BiTree; 1. 已知二叉树的前序遍历和中序遍历，求二叉树的后序遍历结果 题目： 根据前序和中序建立二叉树再输出结果。 C++编程结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;typedef struct TNode &#123; struct TNode* lchild; // 左孩子 struct TNode* rchild; // 右孩子 char data; // 数据域&#125; TNode, *BiTree;BiTree CreatTree(char Pre[], char In[], int pl, int pr, int il, int ir) &#123; BiTree root = NULL; root = new TNode(); root -&gt; data = Pre[pl]; int index = 0; for (index = il; In[index] != Pre[pl]; index++); // 寻找前序第一个节点在中序中的位置 int lenl = index - il; int lenr = ir - index; if (lenl) &#123; root -&gt; lchild = CreatTree(Pre, In, pl + 1, pl + lenl, il, il + lenl - 1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if (lenr ) &#123; root -&gt; rchild = CreatTree(Pre, In, pr - lenr + 1, pr, ir - lenr + 1, ir); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125;void PostOrder(BiTree T) &#123; if (T != NULL) &#123; PostOrder(T -&gt; lchild); PostOrder(T -&gt; rchild); printf("%c", T -&gt; data); &#125;&#125;void PostDeletTree(BiTree root) &#123; if(root != NULL) &#123; BiTree(root -&gt; lchild); BiTree(root -&gt; rchild); delete(root); &#125;&#125;int main() &#123; char pre[26]; char in[26]; while(gets(pre) &amp;&amp; gets(in)) &#123; int len = 0; for(len = 0; pre[len] != '\0'; len++); //建立二叉树 BiTree root = CreatTree(pre, in, 0, len - 1, 0, len - 1); PostOrder(root); // 后序遍历二叉树 printf("\n"); PostDeletTree(root); // 释放建立二叉树时动态分配的内存 &#125; return 0;&#125; 2. 二叉排序树 题目： 输入一系列整数，建立二叉排序树，并对二叉排序树进行前序中序和后序遍历输入：第一行包括一个整数n(0&lt;n&lt;100)，接下来的一行包括n个整数。提示： 输入可能包含重复数字，单输出的时候不用输出重复数字。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;typedef struct BNode &#123; struct BNode* lchild; // 左孩子 struct BNode* rchild; // 右孩子 int data; // 数据域&#125; BNode, *BiTree;void PreOrder(BiTree T) &#123; if (T != NULL) &#123; printf("%d ", T -&gt; data); PreOrder(T -&gt; lchild); PreOrder(T -&gt; rchild); &#125;&#125;void InOrder(BiTree T) &#123; if (T != NULL) &#123; InOrder(T -&gt; lchild); printf("%d ", T -&gt; data); InOrder(T -&gt; rchild); &#125;&#125;void PostOrder(BiTree T) &#123; if (T != NULL) &#123; PostOrder(T -&gt; lchild); PostOrder(T -&gt; rchild); printf("%d ", T -&gt; data); &#125;&#125;BiTree BiSortTree(BiTree &amp;root, int a) &#123; //建立二叉排序树的算法 if (root) &#123; if (a &lt; root -&gt; data) root -&gt; lchild = BiSortTree(root -&gt; lchild, a); else if(a &gt; root -&gt; data) root -&gt; rchild = BiSortTree(root -&gt; rchild, a); &#125; else &#123; root = new BNode(); root -&gt; data = a; &#125; return root;&#125;void PostDeletTree(BiTree root) &#123; // 后序删除二叉排序树 if(root != NULL) &#123; BiTree(root -&gt; lchild); BiTree(root -&gt; rchild); delete(root); &#125;&#125;int main() &#123; int n = 0; while(scanf("%d", &amp;n) != EOF) &#123; BiTree T; int x; while(n--) &#123; scanf("%d", &amp;x); T = BiSortTree(T, x); &#125; printf("前序遍历结果："); PreOrder(T); printf("\n中序遍历结果: "); InOrder(T); printf("\n后序遍历结果："); PostOrder(T); printf("\n"); PostDeletTree(T); &#125; return 0;&#125; 3. 二叉排序树 题目： 开始是一个数n(0&lt;n&lt;20)表示有n个需要判断，n=0时结束，接下来一行是一个数字序列，序列长度小于10，包含0-9的数字，无重复，根据这个序列可以构造一个二叉排序树。接下来的n行有n个序列，每个序列的格式跟第一个一样，请判断这两个序列能否组成同一棵二叉树。 样例输入： 2 567432 543267 576342 样例输出： YES NO 思路：比较二叉排序树的遍历结果来判断两棵树是否一样123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;typedef struct BNode &#123; struct BNode* lchild; // 左孩子 struct BNode* rchild; // 右孩子 char data; // 数据域&#125; BNode, *BiTree;void PreOrder(BiTree T, char po[], int &amp;index) &#123; if (T != NULL) &#123; po[index] = T -&gt; data; index++; PreOrder(T -&gt; lchild, po, index); PreOrder(T -&gt; rchild, po, index); &#125;&#125;void InOrder(BiTree T, char po[], int &amp;index) &#123; if (T != NULL) &#123; InOrder(T -&gt; lchild, po, index); po[index] = T -&gt; data; index++; InOrder(T -&gt; rchild, po, index); &#125;&#125;BiTree BiSortTree(BiTree &amp;root, int a) &#123; //建立二叉排序树的算法 if (root) &#123; if (a &lt; root -&gt; data) root -&gt; lchild = BiSortTree(root -&gt; lchild, a); else if(a &gt; root -&gt; data) root -&gt; rchild = BiSortTree(root -&gt; rchild, a); &#125; else &#123; root = new BNode(); root -&gt; data = a; &#125; return root;&#125;void PostDeletTree(BiTree root) &#123; // 后序删除二叉排序树 if(root != NULL) &#123; BiTree(root -&gt; lchild); BiTree(root -&gt; rchild); delete(root); &#125;&#125;int main() &#123; int n = 0; while(scanf("%d", &amp;n) != EOF &amp;&amp; n != 0) &#123; BiTree T = NULL; char old[10] = &#123;'\0'&#125;; char pold[10] = &#123;'\0'&#125;; char iold[10] = &#123;'\0'&#125;; char str[10] = &#123;'\0'&#125;; char pstr[10] = &#123;'\0'&#125;; char istr[10] = &#123;'\0'&#125;; int index = 0; scanf("%s", old); int i = 0; for (i = 0; old[i] != '\0'; i++) T = BiSortTree(T, old[i]); index = 0; PreOrder(T, pold, index); index = 0; InOrder(T, iold, index); PostDeletTree(T); for (int j = 0; j &lt; n; j++) &#123; // 将指针初始化为空很重要 BiTree NT = NULL; for (int l = 0; l &lt; n; l++) &#123; str[l] = '\0'; pstr[l] = '\0'; istr[l] = '\0'; &#125; scanf("%s", str); for (int k = 0; str[k] != '\0'; k++) NT = BiSortTree(NT, str[k]); index = 0; PreOrder(NT, pstr, index); index = 0; InOrder(NT, istr, index); if (strcmp(pold, pstr) == 0 &amp;&amp; strcmp(iold, istr) == 0) printf("YES\n"); else printf("NO\n"); PostDeletTree(NT); &#125; printf("please input the number n: "); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F27%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[@TOC 贪心算法胖耗子的交易题目描述： FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain. 输入： The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1&apos;s. All integers are not greater than 1000. 输出： For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain. 样例输入： 5 3 7 2 4 3 5 2 20 3 25 18 24 15 15 10 -1 -1 样例输出： 13.333 31.500 简单说来就是：m元钱，n中物品，每种物品j磅，总价值f元。 解题思路：每一次购买的时候先购买性价比最高的物品，再接着购买性价比较低的物品，一直以这个思路购买。 C++实现算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct JavaBean &#123; double jbean; // 物品的总质量 double fcat; // 物品的总价格 double per; // 物品的性价比 bool operator &lt; (const JavaBean &amp;jb) const &#123; // 重载小于运算符，确保可以使用sort函数将数组按照降序排列 return per &gt; jb.per; &#125;&#125; buff[1001];int main() &#123; double m; int n; while(scanf("%lf%d", &amp;m, &amp;n) != EOF) &#123; if (m == -1 || n == -1) break; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf", &amp;buff[i].jbean, &amp;buff[i].fcat); buff[i].per = buff[i].jbean / buff[i].fcat; &#125; sort(buff, buff + n); double money = m; int i = 0; double max = 0; for (int i = 0; i &lt; n; i++) &#123; if (money &gt; 0) &#123; if (money &gt; buff[i].fcat) &#123; money -= buff[i].fcat; max += buff[i].jbean; &#125; else &#123; max += buff[i].per * money; money = 0; &#125; &#125; else &#123; break; &#125; &#125; printf("%.3lf\n", max); &#125; return 0;&#125; 今年暑假不AC题目描述：输入数据包含多个测试实例，每个测试实例的第一行只有一个整树n(0 &lt; n &lt;= 100), 表示你喜欢看的节目总数，然后是n行数据，有两个整数ts和te分别表示节目的开始时间和结束时间，你如何安排时间表才能尽可能多的看完节目。 样例输入： 12 1 3 3 4 0 7 3 8 15 19 15 20 10 15 8 18 6 12 5 10 4 14 2 9 0 样例输出： 5 解析：第一个选择的节目一定是结束时间最早的节目，那么第一个选定后，第二个的选择同样是相同的道理。 C++实现程序：123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Time &#123; int start; int end; bool operator &lt; (const Time &amp;T) const &#123; return end &lt; T.end; &#125;&#125; buff[101];int main() &#123; int n; while(scanf("%d", &amp;n) != EOF &amp;&amp; n != 0) &#123; for (int i = 0; i &lt; n; i++) scanf("%d%d", &amp;buff[i].start, &amp;buff[i].end); sort(buff, buff + n); int earend = 0; int num = 1; for (int i = 1; i &lt; n; i++) &#123; if (buff[i].start &gt;= buff[earend].end) &#123; num++; earend = i; &#125; else if (buff[i].start &gt;= buff[earend].start &amp;&amp; buff[i].end &lt; buff[earend].end) &#123; earend = i; &#125; &#125; printf("%d\n", num); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F27%2F%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[@TOC 查找1. 查找学生信息 题目描述： 输入N个学生的信息，然后进行查询。 输入： 输入的第一行为N，即学生的个数(N&lt;=1000) 接下来的N行包括N个学生的信息，信息格式如下： 01 李江 男 21 02 刘唐 男 23 03 张军 男 19 04 王娜 女 19 然后输入一个M(M&lt;=10000),接下来会有M行，代表M次查询，每行输入一个学号，格式如下： 02 03 01 04 输出： 输出M行，每行包括一个对应于查询的学生的信息。 如果没有对应的学生信息，则输出“No Answer!” 样例输入： 4 01 李江 男 21 02 刘唐 男 23 03 张军 男 19 04 王娜 女 19 5 02 03 01 04 03 样例输出： 02 刘唐 男 23 03 张军 男 19 01 李江 男 21 04 王娜 女 19 03 张军 男 19 思路：先对学生按照学号进行排序，然后使用二分查找即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;struct Student &#123; char id[10]; char name[20]; char sex[5]; int age; bool operator &lt; (const Student &amp; S) const &#123; return strcmp(id, S.id) &lt; 0; &#125;&#125; buff[1001];int BinarySearch(Student buff[], char sid[], int len) &#123; int low = 0; int high = len - 1; int mid = 0; int ans = -1; while(low &lt;= high) &#123; mid = (low + high) / 2; if (strcmp(buff[mid].id, sid) == 0) &#123; ans = mid; break; &#125; else if (strcmp(buff[mid].id, sid) &lt; 0) &#123; low = mid + 1; high = len - 1; &#125; else &#123; low = 0; high = mid - 1; &#125; &#125; return ans;&#125;int main() &#123; int n; int m; int temp = 0; char sid[10]; while(scanf("%d", &amp;n) != EOF) &#123; for (int i = 0; i &lt; n; i++) &#123; scanf("%s%s%s%d", buff[i].id, buff[i].name, buff[i].sex, &amp;buff[i].age); &#125; sort(buff, buff+n); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; buff[i].id &lt;&lt; endl; &#125; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%s", sid); temp = BinarySearch(buff, sid, n); if (temp &gt; -1) &#123; cout &lt;&lt; buff[temp].id &lt;&lt; " " &lt;&lt; buff[temp].name &lt;&lt; " "; cout &lt;&lt; buff[temp].sex &lt;&lt; " " &lt;&lt; buff[temp].age &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "No Answer" &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F27%2F%E5%93%88%E5%B8%8C%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[@TOC 哈希的应用于排版Hash的应用 统计某个成绩的学生的人数； 给定n个整数，输出前m大的数 使用桶排序的思路来做。 排版题1. 梯形排版 输入一个数h，输出一个上底为h，高为h的梯形。 如： 3 *** ***** ******* 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int n; int space = 0; int out = 0; while(scanf("%d", &amp;n) != EOF) &#123; for(int i = 1; i &lt;= n; i++) &#123; space = (n - i) * 2; out = n + (i - 1) * 2; while(space--) cout &lt;&lt; " "; while(out--) cout &lt;&lt; "*"; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 2. 叠箩筐 题目描述： 把一个个大小差一圈的筐叠上去，使得从上往下看时，边筐花色交错。这个工作现在要让计算机来完成，得看你的了。 输入： 输入是一个个的三元组，分别是，外筐尺寸n（n为满足0&lt;n&lt;80的奇整数），中心花色字符，外筐花色字符，后二者都为ASCII可见字符； 输出： 输出叠在一起的筐图案，中心花色与外筐花色字符从内层起交错相叠，多筐相叠时，最外筐的角总是被打磨掉。叠筐与叠筐之间应有一行间隔。 样例输入： 11 B A 5 @ W 样例输出： AAAAAAAAA ABBBBBBBBBA ABAAAAAAABA ABABBBBBABA ABABAAABABA ABABABABABA ABABAAABABA ABABBBBBABA ABAAAAAAABA ABBBBBBBBBA AAAAAAAAA @@@ @WWW@ @W@W@ @WWW@ @@@ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;using namespace std;int main() &#123; int n; char in; char out; char temp; int head = 0; char arr[80][80]; while(scanf("%d %c %c", &amp;n, &amp;in, &amp;out) == 3) &#123; arr[0][0] = arr[0][n - 1] = ' '; arr[n - 1][0] = arr[n - 1][n - 1] = ' '; arr[n / 2][n / 2] = in; bool bin = false; bool bout = true; for (int i = n / 2 - 1; i &gt; 0; i--) &#123; if (bout &amp;&amp; !bin) &#123; temp = out; bout = false; bin = true; &#125; else if (bin &amp;&amp; !bout)&#123; temp = in; bin = false; bout = true; &#125; for (int j = i; j &lt; n - i; j++) &#123; arr[i][j] = temp; arr[n - i - 1][j] = temp; &#125; for (int k = i + 1; k &lt; n - i - 1; k++) &#123; arr[k][i] = temp; arr[k][n - i - 1] = temp; &#125; &#125; if (bin) temp = in; else if (bout) temp = out; head = n - 2; for (int head = 1; head &lt; n - 1; head++) &#123; arr[0][head] = temp; arr[n - 1][head] = temp; arr[head][0] = temp; arr[head][n - 1] = temp; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; arr[i][j]; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F27%2F%E5%93%88%E5%B8%8C%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC Hash的应用 统计某个成绩的学生的人数； 给定n个整数，输出前m大的数 使用桶排序的思路来做。 排版题1. 梯形排版 输入一个数h，输出一个上底为h，高为h的梯形。 如： 3 *** ***** ******* 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int n; int space = 0; int out = 0; while(scanf("%d", &amp;n) != EOF) &#123; for(int i = 1; i &lt;= n; i++) &#123; space = (n - i) * 2; out = n + (i - 1) * 2; while(space--) cout &lt;&lt; " "; while(out--) cout &lt;&lt; "*"; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 2. 叠箩筐 题目描述： 把一个个大小差一圈的筐叠上去，使得从上往下看时，边筐花色交错。这个工作现在要让计算机来完成，得看你的了。 输入： 输入是一个个的三元组，分别是，外筐尺寸n（n为满足0&lt;n&lt;80的奇整数），中心花色字符，外筐花色字符，后二者都为ASCII可见字符； 输出： 输出叠在一起的筐图案，中心花色与外筐花色字符从内层起交错相叠，多筐相叠时，最外筐的角总是被打磨掉。叠筐与叠筐之间应有一行间隔。 样例输入： 11 B A 5 @ W 样例输出： AAAAAAAAA ABBBBBBBBBA ABAAAAAAABA ABABBBBBABA ABABAAABABA ABABABABABA ABABAAABABA ABABBBBBABA ABAAAAAAABA ABBBBBBBBBA AAAAAAAAA @@@ @WWW@ @W@W@ @WWW@ @@@ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;using namespace std;int main() &#123; int n; char in; char out; char temp; int head = 0; char arr[80][80]; while(scanf("%d %c %c", &amp;n, &amp;in, &amp;out) == 3) &#123; arr[0][0] = arr[0][n - 1] = ' '; arr[n - 1][0] = arr[n - 1][n - 1] = ' '; arr[n / 2][n / 2] = in; bool bin = false; bool bout = true; for (int i = n / 2 - 1; i &gt; 0; i--) &#123; if (bout &amp;&amp; !bin) &#123; temp = out; bout = false; bin = true; &#125; else if (bin &amp;&amp; !bout)&#123; temp = in; bin = false; bout = true; &#125; for (int j = i; j &lt; n - i; j++) &#123; arr[i][j] = temp; arr[n - i - 1][j] = temp; &#125; for (int k = i + 1; k &lt; n - i - 1; k++) &#123; arr[k][i] = temp; arr[k][n - i - 1] = temp; &#125; &#125; if (bin) temp = in; else if (bout) temp = out; head = n - 2; for (int head = 1; head &lt; n - 1; head++) &#123; arr[0][head] = temp; arr[n - 1][head] = temp; arr[head][0] = temp; arr[head][n - 1] = temp; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; arr[i][j]; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F27%2F%E6%97%A5%E6%9C%9F%E7%B1%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[@TOC 日期类问题1. 日期差值 有两个日期，计算两个日期之间的天数，如果两个日期是连续的，我们规定他们之间的天数为两天。 输入： 有多组输入，每组数据有两行，分别表示两个日期，形式为YYYYMMDD； 输出： 每组数据输出一行，即日期差值。 样例输入： 20110412 20110422 样例输出： 11 解析：将原问题统一到一个确定的起点区间上去，比如0年1月1日，当我们输入日期的时候计算出日期与起点区间的差，当我们计算两个日期的差时只需要将它们与起点区间的差相减就OK了，这个做法可以先计算出每个日期与起点日期之间的差，当我们输入日期的时候在O(1)的时间内可以查出当前日期与起点日期的差，相当于是用空间换取时间的做法。 注意：闰年的判断条件是：当年数如果不能被100整除但是能被4整除时为闰年或者当年数能被40整除时为闰年 实现的C++程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define ISLEAPYEAR(x) (x % 100 != 0 &amp;&amp; x % 4 == 0) || x % 400 == 0 ? 1 : 0// 使用宏定义来判断一年是不是闰年 int DayofMonth[13][2] = &#123; 0,0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;;struct Date &#123; int year; int month; int day; void NextDay() &#123; // 计算下一天的日期 day++; if (day &gt; DayofMonth[month][ISLEAPYEAR(year)]) &#123; day = 1; month++; if (month &gt; 12) &#123; month = 1; year++; &#125; &#125; &#125;&#125;;int buf[5001][13][32]; //保存预处理的天数int abs(int x) &#123; return x &lt; 0 ? -x : x;&#125;int main() &#123; Date tmp; tmp.year = 0; tmp.month = 1; tmp.day = 1; int count = 0; // 天数计数 while(tmp.year != 5001) &#123; buf[tmp.year][tmp.month][tmp.day] = count; count++; tmp.NextDay(); &#125; int y1, m1, d1; int y2, m2, d2; while(scanf("%4d%2d%2d", &amp;y1, &amp;m1, &amp;d1) != EOF) &#123; scanf("%4d%2d%2d", &amp;y2, &amp;m2, &amp;d2); printf("%d\n", abs(buf[y1][m1][d1] - buf[y2][m2][d2]) + 1); &#125; return 0;&#125; 以上代码简析： （1）将数据本身与数据的存储地址联系起来，存储日期的时候使用三维数组，这样存取方便；（2）程序输入采取了技巧，因为题目规定使用连续的8位数据，所以使用%4d来读取前四位并赋值给year，后面的%2d%2d也是同样的思路；（3）在main函数体外定义预处理数组buf[5001][13][32]，避免函数在运行的时候栈的空间不够而出现栈溢出的情况。 2. Day of Week 给出一个日期，求出这个时期是星期几。 输入样例： 输出样例： 9 October 2001 Tuesday 14 October 2001 Sunday 解析：这个问题也同样可以使用预处理的思路来解决，首先需要知道今天星期几，给定日期与今天相比差几天，利用这个数字对7求模，即可得出给定日期星期几。 (1)C++实现程序如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;#define ISLEAPYEAR(x) (x % 100 != 0 &amp;&amp; x % 4 == 0) || x % 400 == 0 ? 1 : 0char DayofMonth[13][2] = &#123; 0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;;struct Date&#123; int year; int month; int day; void NextDay() &#123; day++; if (day &gt; DayofMonth[month][ISLEAPYEAR(year)]) &#123; day = 1; month++; if (month &gt; 12) &#123; month = 1; year++; &#125; &#125; &#125;&#125;;char MonthName[13][20] = &#123; "", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"&#125;;char WeekName[7][20] = &#123; "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"&#125;;int buff[5001][13][32];int main() &#123; Date tmp; tmp.year = 0; tmp.month = 1; tmp.day = 1; int count = 1; while(tmp.year != 5001) &#123; // 预处理天数 buff[tmp.year][tmp.month][tmp.day] = count; tmp.NextDay(); count++; &#125; int year; char month[20]; int day; while(scanf("%d%s%d", &amp;day, month, &amp;year) != EOF) &#123; int i = 0; while(strcmp(month, MonthName[i]) != 0) i++; // for (i = 0; i &lt; 13 &amp;&amp; month != MonthName[i]; i++); // 字符数组不可以这样比较，month是month[0]的地址， // MonthName[i]是MonthName[i][0]的地址 // 今天的日期是2018那年12月27日，星期四 int days = buff[year][i][day] - buff[2018][12][27]; days += 4; // 因为今天是周四，所以需要加上这个日期 // 对日期取模，并且为保证日期下标为正，这里必须加7 puts(WeekName[(days % 7 + 7) % 7]); &#125; return 0;&#125; (2)Zeller公式求解 历史上的某一天是星期几？未来的某一天是星期几？关于这个问题，有很多计算公式（两个通用计算公式和一些分段计算公式），其中最著名的是蔡勒（Zeller）公式。即用公式： w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1 公式中的符号含义如下，w：星期；c：世纪-1；y：年（后两位数）；m：月（m大于等于3，小于等于14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，比如2003年1月1日要看作2002年的13月1日来计算）；d：日；[ ]代表取整，即只要整数部分。(C是世纪数减一，y是年份后两位，M是月份，d是日数。1月和2月要按上一年的13月和 14月来算，这时C和y均按上一年取值。)算出来的W除以7，余数是几就是星期几。如果余数是0，则为星期日。 以2049年10月1日（100周年国庆）为例，用蔡勒（Zeller）公式进行计算，过程如下： 蔡勒（Zeller）公式： w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1 =49+[49/4]+[20/4]-2×20+[26× (10+1)/10]+1-1 =49+[12.25]+5-40+[28.6] =49+12+5-40+28 =54 (除以7余5)即2049年10月1日（100周年国庆）是星期5。 C++++实现如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;char MonthName[13][20] = &#123; "", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"&#125;;char WeekName[7][20] = &#123; "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"&#125;;int main() &#123; int preyear; int postyear; char month[20]; int day; while(scanf("%d%s%2d%2d", &amp;day, month, &amp;preyear, &amp;postyear) != EOF) &#123; int i = 0; while(strcmp(month, MonthName[i]) != 0) i++; if (i == 1 || i == 2) i += 12; // 蔡勒公式： w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1 int weeks = postyear + postyear / 4 + (preyear / 4) - 2 * preyear + (26 * (i + 1) / 10) + day - 1; puts(WeekName[weeks % 7]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F26%2F%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC 排序应用1. 成绩排序 输入N个学生的数据，将学生的成绩由低到高排序，如果成绩相同，那么按照姓名的字母序排序，如果字母序也相同，那么按照年龄排序。 样例输入: 样例输出： 3 abc 20 99 bcd 19 97 bcd 19 97 bed 20 97 bed 20 97 abc 20 99 （1）以下是实现的C++程序1：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;struct Student &#123; char name[101]; int age; int score;&#125; buf[1000];bool cmp(Student A, Student B) &#123; // 如果分数不相同，则分数低的在前 if (A.score &lt; B.score) return A.score &lt; B.score; // 如果分数相同，则姓名字母字典序小的在前 int tmp = strcmp(A.name, B.name); if(tmp != 0) return tmp &lt; 0; else return A.age &lt; B.age; // 如果分数和字母字典序相同，则年龄小的在前&#125;int main() &#123; int n; while(scanf("%d", &amp;n) != EOF) &#123; for (int i = 0; i &lt; n; i++) &#123; scanf("%s%d%d", &amp;buf[i].name, &amp;buf[i].age, &amp;buf[i].score); &#125; // 使用重载形式表明将要使用自己定义的排序规则 sort(buf, buf + n, cmp); printf("排序后的结果是：\n"); for (int i = 0; i &lt; n; i++) &#123; printf("%s %d %d\n", buf[i].name, buf[i].age, buf[i].score); &#125; &#125; return 0;&#125; （2）以下是实现的C++程序1：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;struct Student &#123; char name[101]; int age; int score; bool operator &lt; (const Student &amp;B) const &#123; // 利用C++算符重载直接定义小于运算符 // 如果分数不相同，则分数低的在前 if (score &lt; B.score) return score &lt; B.score; // 如果分数相同，则姓名字母字典序小的在前 int tmp = strcmp(name, B.name); if(tmp != 0) return tmp &lt; 0; else return age &lt; B.age; // 如果分数和字母字典序相同，则年龄小的在前 &#125;&#125; buf[1000];int main() &#123; int n; while(scanf("%d", &amp;n) != EOF) &#123; for (int i = 0; i &lt; n; i++) &#123; scanf("%s%d%d", &amp;buf[i].name, &amp;buf[i].age, &amp;buf[i].score); &#125; sort(buf, buf + n); printf("排序后的结果是：\n"); for (int i = 0; i &lt; n; i++) &#123; printf("%s %d %d\n", buf[i].name, buf[i].age, buf[i].score); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F26%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——内部排序之交换排序内部排序排序的一篇优秀博客 插入排序 折半插入排序 希尔排序（不稳定） 冒泡排序 123456789101112131415161718void BubbleSort(ElemType A[], int n) &#123; int temp = 0; // 标记数组是不是有序的； bool flag = false; for (int i = 0; i &lt; n - 1; i++) &#123; flag = false; for (int j = n - 1; j &gt; i; j--) &#123; if(A[j - 1].key &gt; A[j].key) &#123; temp = A[j - 1].key; A[j - 1].key = A[j].key; A[j].key = temp; flag = true; &#125; &#125; if(flag == false) return; &#125;&#125; 快速排序 1234567891011121314151617181920void QuickSort(ElemType A[], int low, int high) &#123; if (low &lt; high) &#123; int mid = Partion(A, low, high); QuickSort(A, low, mid - 1); QuickSort(A, mid + 1, high); &#125;&#125;int Partion(ElemType A[], int low, int high) &#123; ElemType privot = A[low]; // 将数组的第一个元素设置成枢纽值，对数组进行划分 while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; return low;&#125; 算法练习 线性表按顺序存储，使用最少的时间和空间将所有奇数移动到偶数的前面 123456789101112131415void OddEvenEx(ElemType A[], int n) &#123; int i = 0; int j = n - 1; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; A[j] % 2 != 1) --j; // 从后向前寻找第一个奇数 while(i &lt; j &amp;&amp; A[i] % 2 != 0) ++i; // 从前向后寻找第一个偶数 if (i &lt; j) &#123; Swap(A[i], A[j]); ++i; --j; &#125; &#125;&#125; 试在数组A[1…n]中寻找第k小的数。 1234567891011121314151617181920212223242526272829303132ElemType KthLeast(ElemType A[], int k, int low, int high) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; /*这里使用递归的方式来实现 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; low = low + 1; high = n - 1; &#125; else &#123; high = low - 1; low = 0; &#125; */ //这里的k如果数组下表是从0开始的话，最开始的时候k需要减1 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; // 在后一部分继续寻找 return KthLeast(A, k, low + 1, high_temp); &#125; else &#123; // 在前一部分继续寻找 return KthLeast(A, k, low_temp, low - 1); &#125;&#125; 2016年计算机联考真题 已知由n（n&gt;=2）个正整数构成的集合A ，将其划分成两个不相交的子集A1和A2，元素个数分别为n1和n2，A1和A2中元素之和分别为S1和S2。设计一个尽可能高效的划分算法，满足|n1-n2|最小且|S1-S2|最大。要求： 1）给出算法的基本设计思想。 2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。 3）说明你所设计算法的平均时间复杂度和空间复杂度。 算法解析：这道题目是求第k大的数的一个变种. |n1-n2|最小且|S1-S2|最大，在数组元素为奇数个的时候，|n1-n2|最小为1，那么把前n/2个最小的数放在一个数组，后面n/2+1个比较大的数放在另一个数组，这时得到的结果满足条件；数组元素为偶数个的时候，|n1-n2|最小为0，所以，第一个数组里面的数是比较小的前n/2个数，第二个数组的是后n/2个比较大的数 1234567891011121314151617181920void ArrPartion(ElemType A[], int low, int high, int k) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt; privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt; privot) ++low; A[high] = A[low]; &#125; A[low] = privot; if (low == k) &#123; return; &#125; else if (low &lt; k) &#123; ArrPartion(A, low_temp, low - 1, k); &#125; else &#123; ArrPartion(A, low + 1, high_temp, k); &#125;&#125; 荷兰国旗难题 现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。 算法思想：对线性表从前往后进行扫描，将红色的条块放到前面，蓝色对的条块放到后面，白色的条块自然也就在中间的位置，故而需要三个指针，begin和end分别指向数组的头部和尾部，current指针从前往后扫描，如果遇到红色就和头部进行交换，如果遇到蓝色则和尾部交换。 算法实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef enum&#123;RED, WHITE, BLUE&#125; color;void Holland_Partion(color arr[], int n) &#123; int begin = 0; int end = n - 1; int current = begin; color temp; while(current &lt;= end) &#123; switch(arr[current])&#123; case RED: temp = arr[begin]; arr[begin] = arr[current]; arr[current] = temp; begin++; current++; break; case WHITE: current++; break; case BLUE: temp = arr[end]; arr[end] = arr[current]; arr[current] = temp; end--; // current没有++，因为担心交换后current指向的仍为BLUE &#125; &#125;&#125;int main() &#123; color arr[12]; for(int i = 0; i &lt; 12; i+=3) &#123; arr[i] = WHITE; arr[i + 1] = BLUE; arr[i + 2] = RED; &#125; for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; Holland_Partion(arr, 12); for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F25%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——归并排序与基数排序归并排序 归并排序遵循了分治模式，直观上就是分解：分解带排序的元素的序列成各具n/2个元素的两个子序列；解决：使用归并排序递归的排序两个子序列；合并：合并两个已排序的子序列以产生已排序的答案。 首先看看如何合并已排序的两个数组，为了避免在每一个基本步骤都必须检查数组是否已经到了最末端，在两个数组的最末端都放置了哨兵——将两个数组的最末端的元素设置为最大，这样就可以避免对数组的检查： 12345678910111213141516171819202122232425262728int* MergeSort(int* arr, int p, int q, int r) &#123; //the sort interval is arr[p, q] to arr[q + 1, r] int n1 = q - p + 1; int n2 = r - q; int* left = (int*)malloc(sizeof(1) * (n1+1)); int* right = (int*)malloc(sizeof(1) * (n2+1)); for (int i = p; i &lt;= q; i++) left[i-p] = arr[i]; for (int i = q + 1; i &lt;= r; i++) right[i - q - 1] = arr[i]; left[n1] = INT_MAX; right[n2] = INT_MAX; int i = 0; int j = 0; for (int k = p; k &lt;= r; k++) &#123; if (left[i] &lt;= right[j]) &#123; arr[k] = left[i]; i += 1; &#125; else if (left[i] &gt; right[j]) &#123; arr[k] = right[j]; j += 1; &#125; &#125; free(left); free(right); return arr; &#125; 下面使用循环不变式方法来证明这个算法的正确性：初始化：在循环的第一次迭代之前，有k=p,数组arr[p, k - 1]为空，i， j 均为0，说明left[i]和right[j]都是各自所在数组里最小的元素，且这两个元素均没有被复制到arr数组里面；保持：为了更好的理解循环不变式，首先假设left[i] &lt;= right[j]，这时left[i]是最小的没有被复制到数组里的最小的元素，将left[i]复制到数组里面之后数组arr[p…k]包含了k-p-1个最小的元素，然后p 和 i，均加1，为下一次迭代重新建立了循环不变式。终止：循环终止的条件是k=r+1。这个时候数组包含了两个数组的所有元素，且是有序的。综上所述，证明了上述算法的正确性！ 接下来考虑递归算法： 123456789int* Merge(int* arr, int p, int r) &#123; if (p &lt; r) &#123; int q = (p + r) / 2; Merge(arr, p, q); Merge(arr, q + 1, r); MergeSort(arr, p, q, r); &#125; return arr; &#125; 递归算法将一个数组分成两半，分别对这两半进行排序之后，再将这两个排好序的数组组合成为一个数组。 接下来分析归并算法的时间复杂度：每一次都将一个节点划分成为两个，直到所有的节点都被划分成为最小的单位为止，划分的时候会产生log n + 1层，而对于每一层的划分，总的代价都是cn(遍历大数组，产生每一个小数组)，所以递归的总的代价就是cn(log n + 1) ，时间复杂度为 n(log n). 以下是本次在LeetCode上面所做的题目： Sort a linked list in O(n log n) time using constant space complexity.根据上面的分析，程序如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* sortList(struct ListNode* head) &#123; int* MergeSort(int* arr, int p, int q, int r) &#123; //the sort interval is arr[p, q] to arr[q + 1, r] int n1 = q - p + 1; int n2 = r - q; int* left = (int*)malloc(sizeof(1) * (n1+1)); int* right = (int*)malloc(sizeof(1) * (n2+1)); for (int i = p; i &lt;= q; i++) left[i-p] = arr[i]; for (int i = q + 1; i &lt;= r; i++) right[i - q - 1] = arr[i]; left[n1] = INT_MAX; right[n2] = INT_MAX; int i = 0; int j = 0; for (int k = p; k &lt;= r; k++) &#123; if (left[i] &lt;= right[j]) &#123; arr[k] = left[i]; i += 1; &#125; else if (left[i] &gt; right[j]) &#123; arr[k] = right[j]; j += 1; &#125; &#125; free(left); free(right); return arr; &#125; int* Merge(int* arr, int p, int r) &#123; if (p &lt; r) &#123; int q = (p + r) / 2; Merge(arr, p, q); Merge(arr, q + 1, r); MergeSort(arr, p, q, r); &#125; return arr; &#125; int size = 0; struct ListNode* temp = head; while (temp != NULL) &#123; size ++; temp = temp -&gt; next; &#125; if (size &gt; 1) &#123; int* arr1 = (int*)malloc(sizeof(1) * size); size = 0; temp = head; while (temp != NULL) &#123; arr1[size] = temp -&gt; val; size ++; temp = temp -&gt; next; &#125; Merge(arr1, 0, size - 1); temp = head; size = 0; while (temp != NULL) &#123; temp -&gt; val = arr1[size]; size ++; temp = temp -&gt; next; &#125; free(arr1); &#125; return head;&#125; 基数排序]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F25%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——内部排序之选择排序简单选择排序选择排序开始的时候，我们扫描整个列表，找到它的最小元素然后和第一个元素交换，将最小元素放到它在有序表的最终位置上。然后我们从第二个元素开始扫描列表，找到最后n-1个元素的最小元素，再和第二个元素交换位置，把第二小的元素放在它最终的位置上。如此循环下去，在n-1遍以后，列表就排好序了。 算法： 123456789101112void SelectSort(ElemType A[], int n) &#123; int min = 0; for (int i = 0; i &lt; n-1; i++) &#123; min = i; for (int j = i + 1; j &lt; n, j++) &#123; if (A[j] &lt; A[min]) min = j; &#125; if (min != i) Swap(A[i], A[min]); &#125;&#125; 时间复杂度为O(n^2)，空间复杂度为O(1)。 堆排序1. 堆排序简介： 堆排序是一种树形选择排序的方法，它的特点是：在排序过程中，将L[1…n]看成一棵完全二叉树的顺序存储结构，利用完全二叉树的双亲节点和孩子节点的内在关系，在当前无序区中选择关键字最大的元素。 2. 堆的定义为： 堆分为最大堆和最小堆，其实就是完全二叉树。最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子，左右孩子节点之间元素大小不存在大小关系。 3. 基本思想（大根堆）： （1）构造初始堆：是一个反复筛选的过程，n个节点的完全二叉树，最后一个节点是[n/2]个节点的孩子节点，对[n/2]个节点为根的子树进行筛选，使得该子树成为堆，之后一次向前对各节点[n/2-1….1]为根的子树进行筛选，如果不是堆交换后可能会破坏下一级堆，于是继续采用上述方法构造下一级堆，直到以该节点为根的子树构成堆为止，反复利用这个过程直到根节点。 建立大根堆的算法如下所示：123456789101112131415161718192021222324void BuildMaxHeap(ElemType A[], int len) &#123; // 数组下标是从1开始的 for (int i = len/2; i &gt; 0; i--) AdjustDown(A, i, len);&#125;void AdjustDown(ElemType A[], int k, int len) &#123; // 将元素从k往下进行调整 A[0] = A[k]; // A[0]暂存元素 for (int i = 2 * k; i &lt;= len; i *= 2) &#123; // 沿着k较大的子节点向下筛选 if (i &lt; len &amp;&amp; A[i] &lt; A[i+1]) i++; if(A[0] &gt; A[i]) &#123; break; &#125; else &#123; A[k] = A[i]; // 将子节点的元素调整到双亲节点上； k = i; // 从子节点开始继续往下筛选 &#125; &#125; A[i] = A[0];&#125;向下调整的时间与树高度h有关，为O(h)，建堆的过程中每次向下调整时，大部分节点的高度都比较小，因此可以证明在元素为n个的序列上建堆，其时间复杂度为O(n),说明可以在线性时间内建立一个堆。 （2）排序思路：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn)，由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。12345678// 排序算法void HeapSort(ElemType A[], int len) &#123; BuildMaxHeap(A, len); for (int i = len; i &gt; 1; i--) &#123; Swap(A[i], A[1]); // 输出堆顶元素 AdjustDown(A, 1, i-1); // 把剩余的i-1个元素整理成堆。 &#125;&#125; 4. 堆的插入和删除 （1）堆的删除： 由于堆的堆顶元素很有可能是最大的或者是最小的，所以在删除堆顶元素的时候先将堆顶元素与最后一个元素交换，在从堆顶开始向下的调整操作。 （2）堆的插入：堆的插入操作将元素插入到末尾，再对新节点进行向上的调整操作，向上调整的算法如下所示：12345678910void AdjustUp(ElemType A[], int k, int len) &#123; A[0] = A[k]; for (int i = k / 2; i &gt; 0; i = k / 2) &#123; if (A[i] &lt; A[0]) &#123; A[k] = A[i]; k = i; &#125; &#125; A[k] = A[0]&#125; 5. 时空复杂度空间复杂度为O(1), 时间复杂度：建堆时间为O(n)，排序的时候向下调整的时间复杂度为O(h),所以时间复杂度为O(nlogn).堆排序不是稳定的排序算法。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F25%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——内部排序之插入排序与交换排序排序的一篇优秀博客 插入排序 插入排序 折半插入排序 希尔排序（不稳定）交换排序 冒泡排序 123456789101112131415161718void BubbleSort(ElemType A[], int n) &#123; int temp = 0; // 标记数组是不是有序的； bool flag = false; for (int i = 0; i &lt; n - 1; i++) &#123; flag = false; for (int j = n - 1; j &gt; i; j--) &#123; if(A[j - 1].key &gt; A[j].key) &#123; temp = A[j - 1].key; A[j - 1].key = A[j].key; A[j].key = temp; flag = true; &#125; &#125; if(flag == false) return; &#125;&#125; 快速排序 1234567891011121314151617181920void QuickSort(ElemType A[], int low, int high) &#123; if (low &lt; high) &#123; int mid = Partion(A, low, high); QuickSort(A, low, mid - 1); QuickSort(A, mid + 1, high); &#125;&#125;int Partion(ElemType A[], int low, int high) &#123; ElemType privot = A[low]; // 将数组的第一个元素设置成枢纽值，对数组进行划分 while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; return low;&#125; 算法练习 线性表按顺序存储，使用最少的时间和空间将所有奇数移动到偶数的前面 借助了快排的思路 123456789101112131415void OddEvenEx(ElemType A[], int n) &#123; int i = 0; int j = n - 1; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; A[j] % 2 != 1) --j; // 从后向前寻找第一个奇数 while(i &lt; j &amp;&amp; A[i] % 2 != 0) ++i; // 从前向后寻找第一个偶数 if (i &lt; j) &#123; Swap(A[i], A[j]); ++i; --j; &#125; &#125;&#125; 试在数组A[1…n]中寻找第k小的数。 借助了快排的思路 1234567891011121314151617181920212223242526272829303132ElemType KthLeast(ElemType A[], int k, int low, int high) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; /*这里使用递归的方式来实现 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; low = low + 1; high = n - 1; &#125; else &#123; high = low - 1; low = 0; &#125; */ //这里的k如果数组下表是从0开始的话，最开始的时候k需要减1 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; // 在后一部分继续寻找 return KthLeast(A, k, low + 1, high_temp); &#125; else &#123; // 在前一部分继续寻找 return KthLeast(A, k, low_temp, low - 1); &#125;&#125; 2016年计算机联考真题 已知由n（n&gt;=2）个正整数构成的集合A ，将其划分成两个不相交的子集A1和A2，元素个数分别为n1和n2，A1和A2中元素之和分别为S1和S2。设计一个尽可能高效的划分算法，满足|n1-n2|最小且|S1-S2|最大。要求： 1）给出算法的基本设计思想。 2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。 3）说明你所设计算法的平均时间复杂度和空间复杂度。 借助了快排的思路 算法解析：这道题目是求第k大的数的一个变种。|n1-n2|最小且|S1-S2|最大，在数组元素为奇数个的时候，|n1-n2|最小为1，那么把前n/2个最小的数放在一个数组，后面n/2+1个比较大的数放在另一个数组，这时得到的结果满足条件；数组元素为偶数个的时候，|n1-n2|最小为0，所以，第一个数组里面的数是比较小的前n/2个数，第二个数组的是后n/2个比较大的数 1234567891011121314151617181920void ArrPartion(ElemType A[], int low, int high, int k) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt; privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt; privot) ++low; A[high] = A[low]; &#125; A[low] = privot; if (low == k) &#123; return; &#125; else if (low &lt; k) &#123; ArrPartion(A, low_temp, low - 1, k); &#125; else &#123; ArrPartion(A, low + 1, high_temp, k); &#125;&#125; 荷兰国旗难题 现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。 算法思想：借助了快排的思路对线性表从前往后进行扫描，将红色的条块放到前面，蓝色对的条块放到后面，白色的条块自然也就在中间的位置，故而需要三个指针，begin和end分别指向数组的头部和尾部，current指针从前往后扫描，如果遇到红色就和头部进行交换，如果遇到蓝色则和尾部交换。 算法实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;typedef enum&#123;RED, WHITE, BLUE&#125; color;void Holland_Partion(color arr[], int n) &#123; int begin = 0; int end = n - 1; int current = begin; color temp; while(current &lt;= end) &#123; switch(arr[current])&#123; case RED: temp = arr[begin]; arr[begin] = arr[current]; arr[current] = temp; begin++; current++; break; case WHITE: current++; break; case BLUE: temp = arr[end]; arr[end] = arr[current]; arr[current] = temp; end--; // current没有++，因为担心交换后 // current指向的仍为BLUE &#125; &#125;&#125;int main() &#123; color arr[12]; for(int i = 0; i &lt; 12; i+=3) &#123; arr[i] = WHITE; arr[i + 1] = BLUE; arr[i + 2] = RED; &#125; for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; Holland_Partion(arr, 12); for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F24%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[@TOC 字符串模式匹配简单的字符串模式匹配算法串的模式匹配是求第一个字符串在第二个字符串中的位置1234567891011121314151617int Index(String str, String t) &#123; // 求字符串t在str中的位置。 // str[0]和t[0]存储的是字符串的长度； int i = 1, j = 1; while(i &lt;= str[0] &amp;&amp; j &lt;= t[0]) &#123; if(str[i] == t[j]) &#123; i++; j++; &#125; else &#123; i = i - j + 2; j = 1; &#125; &#125; if (j &gt; t[0]) return i - t[0]; return 0;&#125; 简单模式匹配算法的时间复杂度为O(m*n)，m和n分别为主串和模式串的长度。 改进的模式匹配算法——KMP算法KMP算法可以在O(m+n)的时间数量级上完成串的模式匹配操作。 1234567891011121314151617181920212223242526272829303132void get_next(char T[], int next[]) &#123; int i = 1; next[1] = 0; // next[0]不使用 int j = 0; while(i &lt;= T[0]) &#123; if (j == 0 || T[i] == T[j]) &#123; ++i; ++j; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125;&#125;int KMP(char S[], char T[], int next[], int pos) &#123; // 求模式串T在主串S中第pos个字符之后的位置的KMP算法 i = pos; j = 1; while(i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123; if(j == 0 || S[i] == T[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; if(j &gt; T[0]) return i - T[0]; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F20%2F%E5%9B%BE%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@TOC 图——存储及遍历图的定义定义：图G是由顶点集V和边集E组成，记为G=(V, E),其中V(G)表示图G的顶点的非空有限集，E(G)表示图中的边的集合。顶点的个数称为图的阶。 基本概念： 有向图 无向图 简单图：如果图满如下条件则图称为简单图：（1）不存在重复边；（2）不存在顶点到自身的边；则称图为简单图。 多重图：若图G中某两个节点之间的边数对于一条，又允许顶点通过同一条边和自己相关联，则称图G为多重图。 完全图（也称简单完全图）：无向图中如果任意两个顶点之间都有一条边相关联，则称图为无向完全图。在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图。 子图 连通，连通图和连通分量：在无向图中，如果顶点v和w之间有路径存在，则称v和w是连通的，若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量，如果图中有n个顶点，并且有小于n-1条边，则此图必是非连通图。 强连通图和强连通分量：在有向图中如果从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。 生成树，生成森林：生成树是包含图中所有顶点的一个极小连通子图，如果图中有n个顶点，则它的生成树含有n-1条边。 顶点的度，入度和出度：在无向图中，顶点的度等于边数的二倍；在有向图中度分为入度和出度，有向图中所有顶点的入度和出度之和都等于边数。 边的权和网：边上带有权值的图称为带权图，也称为网。 稠密图，稀疏图：一般当图G满足：|E| &lt; |V|log(|V|)时，将图看成稀疏图。 路径，路径长度和回路：第一个顶点和最后一个顶点相同的路径称为回路或者环。 简单路径和简单回路：在路径序列中，顶点不重复出现的路径称为简单路径，除第一个顶点和最后一个顶点之外，其余顶点不重复的路径成为简单回路。 距离 有向树：有一个顶点入度为0，其余顶点入度为1的树称为有向树。 图的存储及基本操作图的存储 邻接矩阵法 用一个一位数组存储图中顶点的信息，用一个二维数组存储图中边的信息，存储顶点之间邻接关系的二维数组称为邻接矩阵。 图的邻接矩阵的数据结构定义如下： 12345678#define MaxVertexNum 100 //顶点的最大数目typedef char VertexType; //顶点的数据类型typedef int EdgeType; //带权图上边的权值的数据类型typedef struct &#123; VertexType Vex[MaxVertexNum] //顶点表 EdgeType Edge[MaxVertexNum][MaxVertexNum] //边表 int vexnum, edgenum; //当前顶点数和边数&#125;MGraph; 稠密图适合邻接矩阵法。 邻接表法 对图中的每一个节点建立一个单链表。顶点表节点由节点域(data)和指向第一条邻接边的指针firstarc构成，边表由邻接节点域adjvex和指向下一条邻接边的指针域nextarc构成。 图的邻接表的数据结构定义如下： 123456789101112131415#define MaxVertexNum 100typedef struct ArcNode &#123; // 边表节点 int adjvex; // 该弧指向的节点的顶点的位置 struct ArcNode* nextarc; // 指向下一条弧的指针&#125; ArcNode;typedef struct VNode &#123; //顶点表节点。 int data; struct VNode* firstarc;&#125; VNode, AdjList[MaxVertexNum];typedef struct &#123; AdjList vnode; // 邻接表 int vernum, arcnum;&#125; ALGraph; 十字链表在十字链表中很容易找到vi为结尾的弧，和以vi为头的弧。 邻接多重表 图的基本操作 判断图G是否存在无向边&lt;v, w&gt;或有向边(v, w); 列出图G中与x邻接的边； 在图G中插入顶点x； 在图G中删除顶点x； 如果无向边&lt;v, w&gt;或有向边(v, w)不存在则插入； 如果无向边&lt;v, w&gt;或有向边(v, w)存在，则删除此边； 求图G中顶点x的第一个邻接点； 获取图G中无向边&lt;v, w&gt;或有向边(v, w)对应的权值； 设置图G中无向边&lt;v, w&gt;或有向边(v, w)的权值。 图的遍历广度优先搜索BFS广度优先搜索需要借助一个队列来实现 1. 伪代码表示如下所示：123456789101112131415161718192021222324252627282930bool visited[MAX_VERTEX_NUM];void BFSTraverse(Graph G) &#123; for(int i = 0; i &lt; G.vexnum, i++) visited[i] = false; for(int i = 0; i &lt; G.vexnum, i++) if(!visited[i]) BFS(G, i);&#125;void BFS(Graph G, int v) &#123; // 从顶点v出发，广度优先遍历图G，算法借助一个辅助队列Q visit(v); visited[v] = true; InitQueue(Q); EnQueue(Q, v); while(!isEmpty(Q)) &#123; DeQueue(Q, u); for(int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) &#123; // w = NextNeighbor(G, u, w)这个函数的意思 // 是返回除w以外的顶点u的下一个邻接顶点 if(!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w); &#125; &#125; &#125;&#125; 2. 算法性能分析 （1）如果图的存储方式是邻接矩阵存储的话，那么在广度优先遍历的时候每个顶点都需要搜索一次（入队一次），故而时间复杂度是O(|V|)，在搜索任意一个定点的邻接顶点的时候每一条边都会至少搜索一次，所以时间复杂度为O(|E|)，算法总的时间复杂度为O(|V|+|E|)； （2）如果图的存储方式是矩阵存储的话，查找每个顶点需要O(|V|)的是时间复杂度，所以算法的总的时间复杂度是O(|V|^2). 3. BFS算法求解单源最短路径问题 使用BFS，可以求解一个非带权图的单源最短路径。 伪代码表示如下所示：1234567891011121314151617181920212223void BFS(Graph G, int u) &#123; // 从顶点v出发，广度优先遍历图G，算法借助一个辅助队列Q // d[i]表示从u到i的最短路径的长度。 for (int i = 0; i &lt; G.vexnum, i++) d[i] = MAX_INT; visited[u] = true; d[u] = 0; InitQueue(Q); EnQueue(Q, u); while(!isEmpty(Q)) &#123; DeQueue(Q, u); for(int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) &#123; // w = NextNeighbor(G, u, w)这个函数的意思 // 是返回除w以外的顶点u的下一个邻接顶点 if(!visited[w]) &#123; d[w] = d[u] + 1; visited[w] = true; EnQueue(Q, w); &#125; &#125; &#125; &#125; 4. 广度优先生成树在广度优先遍历的过程中，可以得到一棵遍历树，称为广度优先遍历树，树的邻接矩阵的存储是唯一的，所以邻接矩阵存储方式下得到的优先树也是唯一的，树的邻接矩阵存储不是唯一的，所以广度优先树也是不唯一的。 深度优先搜索DFS深度优先搜索基本思想：首先访问图中的某一个顶点u，然后访问与u邻接且未被访问的任一顶点v，在访问与v邻接的任一未被访问的顶点w….依次下去直到不能再往下走了，然后返回到最近未被访问的顶点，若它还有邻接顶点未被访问过，则从改点开始继续上述的搜索过程，直到图中所有顶点都被访问过为止。1. 算法的伪代码表示如下所示：1234567891011121314151617bool visited[MAX_VERTEX_NUM];void DFSTraverse(Graph G) &#123; for(int i = 0; i &lt; G.vexnum, i++) visited[i] = false; for(int i = 0; i &lt; G.vexnum, i++) if(!visited[i]) DFS(G, i);&#125;void DFS(Graph G, int u) &#123; // 采用递归的思路实现广度优先搜索。 visit(u); visited[u] = true; for(int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) if(!visited[w]) DFS(G, w);&#125; 2. 算法性能分析 这个算法采用递归的思路，需要借助递归工作栈，所以它的空间复杂度为O(|V|),邻接矩阵存储时算法时间复杂度为O(|V|^2)，使用邻接矩阵存储时，算法的时间复杂度为O(|V| + |E|)。 3. 深度优先树和生成森林 对连通图DFS产生深度优先生成树，否则产生的将是深度优先生成树林。 图的遍历与连通性对于无向图，如果无向图是连通的，那么遍历一次就能够访问图中的所有节点，若无向图是非连通的，那么每一次遍历只能遍历一个连通分量的所有顶点；对于有向图来说，如果从顶点开始到图的每一个顶点都有路径，则能够访问到图中的所有顶点，否则不能。 算法演练 写出从图的邻接表表示转换成邻接矩阵表示的算法。 12345678910void Convert(ALGraph&amp; G, int arc[M][M]) &#123; VNode* p = NULL; for(int i = 0; i &lt; M; i++) &#123; p = (G -&gt; vnode[i]).firstarc; // 取出顶点i的第一条边 while(p) &#123; // 遍历链表 arc[i][p -&gt; adjvex] = 1; p = p -&gt; nextarc; &#125; &#125;&#125; 设计一个算法，判断一个无向图G是否是一颗树，如果是返回true，否则返回false 123456789101112131415161718192021222324// 算法思路：无向连通图的判断条件是无回路的连通图或者有n-1条边的连通图。这里使用有n-1条边的连通图来作为判断条件bool IsTree(Graph G) &#123; bool visited[MAX_VERTES_NUM]; for(int i = 0; i &lt; G.vernum; i++) visited[i] = false; int vnum = 0, enum = 0; DFS(G, 0, vnum, enum, visited); if(vnum == G.vernum &amp;&amp; enum == (G.vernum - 1)) return true; return false;&#125;void DFS(Graph G, int v, int vnum, int enum, bool visited[]) &#123; visited[v] = true; vnum++; int w = FirstNeighbor(G, v); while(w != -1) &#123; enum++; if(!visited[w]) DFS(G, w, vnum, enum, visited); w = NextNeighbor(G, v, w); &#125;&#125; 图G采用邻接表形式存储，请写出图遍历的非递归深度优先搜索算法。首先看一下图的邻接表形式存储的数据结构： 12345678910#define MaxVertexNum 100typedef struct VNode &#123; //顶点表节点。 int data; struct VNode* nextarc;&#125; VNode, AdjList[MaxVertexNum];typedef struct &#123; AdjList vnode; // 邻接表 int vernum, arcnum;&#125; ALGraph; 算法如下：借助栈来实现回退bool visited[MAX_VERTEX_NUM]; void NRur_DFS(Graph G, int u) { InitStack(sta); for(int i = 0; i &lt; G.vernum; i++) visited[i] = false; Push(sta, u); visited[u] = true; while(!isEmpty(sta)) { Pop(sta, p); visit(p); for(int w = FirstNeighbor(G, p); w &gt;= 0; w = NextNeighbor(G, p, w)) { if(!visited[w]) { Push(sta, w); visted[w] = true; } } }}123456789101112131. 分别使用深度优先搜索和广度优先搜索遍历算法，判别以邻接表方式存储的有向图中是否存在由定点u到定点v的路径。 邻接表形式的图的数据结构如下： ```C++ #define MaxVertexNum 100 typedef struct VNode &#123; //顶点表节点。 int data; struct VNode* nextarc; &#125; VNode, AdjList[MaxVertexNum]; typedef struct &#123; AdjList vnode; // 邻接表 int vernum, arcnum; &#125; ALGraph; BFS:12345678910111213141516171819202122232425bool visited[MaxVertexNum];void BFSPath(Graph G, int u, int v) &#123; for(int i = 0; i &lt; G.vernum; i++) visited[i] = false; return BFS_Path(G, u, v);&#125;bool BFS_Path(Graph G, int u, int v) &#123; visited[u] = true; InitQueue(Q); EnQueue(Q, u); while(!isEmpty(Q)) &#123; DeQueue(Q, u); for(int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) &#123; if(!visited[w]) &#123; visited[w] = true; EnQueue(Q, u); if(w == v) return true; &#125; &#125; &#125; return false;&#125; DFS:bool visited[MaxVertexNum];void DFSPath(Graph G, int u, int v) { for(int i = 0; i &lt; G.vernum; i++) visited[i] = false; return DFS_Path(G, u, v);}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F20%2F%E5%9B%BE%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC 图——应用图广度优先遍历可以判断一个图是否为连通图；广度优先遍历可以求得非带权图的单源最短路径。 最小生成树 Prim算法 Prim算法的时间复杂度为O(|V|^2)，不依赖于|E|，故而适用于求解稠密图的最小生成树。 Kruskal算法 这个算法是按照权值递增的顺序选择合适的边来构造生成树。时间复杂度是O(|E|log|E|) 最短路径 Dijkstra算法求解带权图的单源最短路径问题 Floyd-Warshall算法求解带权图的任意两个顶点之间的最短路径问题 拓扑排序关键路径]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的应用]]></title>
    <url>%2F2018%2F12%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC 二叉树——应用二叉排序树（BST） 二叉排序树的定义 或者是一棵空树，或者有如下性质的树： （1）若左子树非空，则左子树上所有节点关键字值均小于根节点的关键字值；（2）若右子树非空，则右子树上所有节点关键字值均大于根节点的关键字值；（3）左右子树也分别是一颗二叉排序树。因此，对二叉排序树的中序遍历得到的就是一个递增的序列。 二叉排序树的查找 从根节点开始，沿一个分支逐层向下进行比较的过程。若二叉树非空，将给定的关键字与根节点的值比较，如果相同则查找成功，如果不相同，如果给定的关键字的值大于根节点的值那么转向右子树寻找，如果小于则向左子树寻找。 算法表示如下所示： 1234567891011121314151617181920212223242526BSTNode* BST_Search(BiTree T, ElemType key, BSTNode *p) &#123; // 查找函数返回指向关键字值为key的节点指针，如果不存在， // 返回NULL // p指向被查找节点的双亲节点 p = NULL; while(T &amp;&amp; key != T-&gt;data) &#123; p = T; if (key &lt; T -&gt; data) T = T -&gt; lchild; else T = T -&gt; rchild; &#125; return T;&#125;BSTNode* BST_RecurSearch(BiTree T, ElemType key, BSTNode *p) &#123; // 算法的递归实现形式 if (T) &#123; if (key == T -&gt; data) return T; else if (key &lt; T -&gt; data) BST_RecurSearch(T -&gt; lchild, key, T) else BST_RecurSearch(T -&gt; rchild, key, T) &#125;&#125; 二叉排序树的插入在查找的过程中，如果没有查找到关键字值的二叉树时，将节点插入到二叉树中，如果二叉树原本为空则要插入的节点为根节点，如果要插入的值比根节点的值大则插入到右子树中，如果比根节点的值小，则插入到左子树中。 算法如下所示： 12345678910111213141516int BST_Insert(BiTree &amp;T, ElemType key) &#123; // 如果二叉树中存在值为key的节点，那么返回0； // 如果二叉树中不存在值为key的节点，那么插入节点并返回1； if (T == NULL) &#123; T = (BSTNode*)malloc(sizeof(BSTNode)); T -&gt; data = key; T -&gt; lchild = T -&gt; rchild = NULL; return 1; &#125; else if (T -&gt; data == key) &#123; return 0; &#125; else if (key &lt; T -&gt; data) &#123; BST_Insert(T -&gt; lchild, key); &#125; else &#123; BST_Insert(T -&gt; rchild, key); &#125;&#125; 二叉排序树的构造 依次输入数据元素，并且将它们插入到排序树中适当的位置。具体过程是每读入一个元素就建立一个新节点，若二叉树为空则这个节点为根节点，如果二叉树不为空的话，则将这个节点插入二叉树中。 算法如下所示： 12345678void BST_Creat(BiTree &amp;T, ElemType str[], int n) &#123; T == NULL; int i = 0; while(i &lt; n) &#123; BST_Insert(T, str[i]); i++; &#125;&#125; 二叉排序树的删除 删除二叉树节点的过程按照三种情况来处理： （1）如果被删除节点是叶子结点，则直接删除，不会破坏二叉排序树的性质； （2）如果节点只有一颗左子树或者右子树，则让节点的子树称为节点父节点的子树，代替被删除节点的位置； （3）如果被删除节点有左右子树的话，则在右子树中找中序第一个子女填补。 算法表示如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void BST_Delete(BiTree T, ElemType key) &#123; BiTree pre = NULL; BiTree p = BST_Search(T, key, pre); // 查找节点 if (p == NULL) return; if (p -&gt; lchild == NULL &amp;&amp; p -&gt; rchild == NULL) &#123; // 如果是叶子节点则直接删除； if (pre -&gt; lchild == p) pre -&gt; lchild = NULL; else if (pre -&gt; rchild == p) pre -&gt; rchild = NULL; free(p) &#125; else if (p -&gt; lchild == NULL &amp;&amp; p -&gt; rchild != NULL) &#123; // 左子树为空 if (pre -&gt; lchild == p) pre -&gt; lchild = p -&gt; rchild; else if (pre -&gt; rchild == p) pre -&gt; lchild == p -&gt; rchild; free(p) &#125; else if (p -&gt; lchild != NULL &amp;&amp; p -&gt; rchild == NULL) &#123; // 右子树为空 if (pre -&gt; lchild == p) pre -&gt; lchild == p -&gt; lchild; else if (pre -&gt; rchild == p) pre -&gt; rchild = p -&gt; lchild; free(p); &#125; else &#123; // 左右子树都不为空 // 寻找右子树在中序遍历的情况下第一个输出的节点； BiTree temp = p -&gt; rchild; Bitree pre2 = p; while (temp -&gt; lchild != NULL) &#123; temp = temp -&gt; lchild; pre2 = p; &#125; p -&gt; data = temp -&gt; data; // 删除temp节点； if (pre2 -&gt; lchild == temp) pre2 -&gt; lchild == temp -&gt; rchild; if (pre2 -&gt; rchild == temp) pre2 -&gt; rchild == temp -&gt; rchild; free(temp); &#125;&#125; 二叉平衡树（AVL） 平衡二叉树的定义 在插入和删除节点的时候，保证任意节点的左右子树的高度差不超过1，这样的二叉树称为平衡二叉树，简称平衡树。定义左子树和右子树的高度差为平衡因子，则平衡因子的值只可能为-1， 0， 1三种。 所以平衡二叉树可定义为它或者是一颗空树，或者它的左右子树都是平衡二叉树，并且左右子树的高度差不超过1. 平衡二叉树的插入 按照二叉排序树插入节点的规则向二叉树中插入一个节点，插入之后，如果二叉树不再是平衡二叉树那么调整二叉树，使得这个二叉树成为新的平衡二叉树。 失去平衡之后调整可归纳为一下四种情况： （1）LL平衡旋转：在A节点的左孩子（L）的左子树（L）上插入了新节点，导致A的平衡因子从1变成了2，导致以A为根的子树失去平衡，需要一次向右旋转的操作。使得A的左孩子接替A，而A的左孩子的右子节点称为旋转后的A的左孩子节点。 （2）RR平衡旋转：由于在A节点的右孩子（R）的右子树（R）上插入了新的节点，导致A的平衡因子从-1变成了-2，失去平衡。需要一次向左旋转的操作。 （3）LR平衡旋转：在A节点的左孩子（L）的右子树（R）上插入了新节点，导致A的平衡因子从1变成了2，导致以A为根的子树失去平衡，需要两次旋转，先向左旋转，再向右旋转。 （4）RL平衡旋转：在A节点的右孩子（R）的左子树（L）上插入了新节点，导致A的平衡因子从-1变成了-2，导致以A为根的子树失去平衡，需要两次旋转，先右旋转，再左旋转。 平衡二叉树的查找 查找过程与二叉排序树相同。 关于平衡二叉树的具体实现C++程序，可以参考平衡二叉树详解（本地测试过了，程序可以运行） 哈夫曼树与哈弗曼编码 哈夫曼树的定义 在含有N个带权叶子结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也成为最优二叉树。 哈夫曼树的构造 给定N个权值分别为w1, w2, …, Wn的节点。构造哈夫曼树的算法描述如下： （1）将这N个结点分别作为N棵树仅含一个结点的二叉树，构成森林F. （2）构造一个新节点，并从F中选取两棵根结点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根结点的权 值之和。 （3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 （4）重复步骤2和3，直至F中只剩下一棵树为止。 哈弗曼编码 哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码，它是可变长度编码。可变长编码即可以对待处理字符串中不同字符使用不等长的二进制位表示，可变长编码比固定长度编码好很多，可以对频率高的字符赋予短编码，而对频率较低的字符则赋予较长一些的编码，从而可以使平均编码长度减短，起到压缩数据的效果。 哈夫曼编码是前缀编码。如果没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。对前缀编码的解码也是相对简单的，因为没有一个码是另一个编码的前缀，所以可以识别出第一个编码，将它翻译为原码，再对余下的编码文件重复同样操作。 哈夫曼编码首先要构造一棵哈夫曼树，首先，将每个出现的字符当做一个独立的结点，其权值作为它出现的频度（或次数），然后构造哈夫曼树。显然所有字符节点均出现在叶子结点中。我们可以将字符的编码解释为从根至该字符路径上标记的序列，其中标记为0表示”转向左孩子”，标记为1表示为”转向右孩子”。 部分题目算法编写 判断一棵二叉树是否是二叉排序树。 123456789101112131415161718// 方案1：直接在二叉树中比较 bool isBST_Tree(BiTree T) &#123; if (T) &#123; // 左子值大于根节点值 if (T -&gt; lchild &amp;&amp; T -&gt; lchild -&gt; data &gt; T -&gt; data) return false; // 右子值小于根节点值 if (T -&gt; rchild &amp;&amp; T -&gt; rchild -&gt; data &lt; T -&gt; data) return false; // 不存在左右节点 if (T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL) return true; else return isBST_Tree(T -&gt; lchild) &amp;&amp; isBST_Tree(T -&gt; rchild); &#125; &#125; // 方案2：中序遍历二叉树，得到的结果始终满足前一个元素的数据小于后一个元素的数据。 利用二叉树的遍历思想，判断一棵二叉树是否为平衡二叉树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 void Judge_AVL(BiTree T, int &amp;balance, int &amp;h) &#123; // 左右子树的平衡标记和高度 int bl = 0, br = 0, hl = 0, hr = 0; if (T == NULL) &#123; h = 0; balance = 1; &#125; else if (T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL) &#123; h = 1; balance = 1; &#125; else &#123; Judge_AVL(T -&gt; lchild, bl, hl); Judge_AVL(T -&gt; rchild, br, hr); int h = (hl&gt;hr?hl:hr) + 1; if (abs(h) &lt; 2) balance = bl &amp;&amp; br; else balance = 0; &#125; &#125; ``` 3. 设计一个算法，从大到小输出二叉排序树中所有其值不小于k的关键字。 ```C++ void printk(BiTree T, int k) &#123; if (T) &#123; if (T -&gt; data &gt; k) &#123; printk(T -&gt; rchild, k); cout &lt;&lt; T -&gt; data &lt;&lt; " "; printk(T -&gt; lchild, k); &#125; else if (T -&gt; data == k)&#123; cout &lt;&lt; k &lt;&lt; " "; return; &#125; else &#123; return; &#125; &#125; &#125; // 以下的是一个更为简洁的函数； void Printk(BiTree T, int k) &#123; if (T == NULL) return; if (T -&gt; rchild != NULL) Printk(T -&gt; rchild, k); if (T -&gt; data &gt;= k) cout &lt;&lt; T-&gt; data &lt;&lt; " "; if (T -&gt; lchild != NULL) Printk(t -&gt; lchild, k); &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的概念与操作]]></title>
    <url>%2F2018%2F12%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@[TOC]目录 二叉树——概念与操作基本概念二叉树的基本概念与性质 基本概念 二叉树有5种基本形态，特殊的二叉树有满二叉树、完全二叉树、二叉排序树和平衡二叉树。 性质 存储结构 二叉树的存储结构有顺序存储结构和链式存储结构两种。满二叉树和完全二叉树采取顺序存储结构比较合适，树中的节点号可以唯一的反映出节点之间的逻辑关系，可以节省空间也可以利用数组元素的下标确定节点在二叉树中的位置以及节点之间的关系。一般二叉树采用链式结构存储，二叉链表中包含3个域，分别是数据域data、左指针lchild和右指针rchild。二叉树的链式存储结构描述如下：12345// 二叉树链式存储结构typedef struct BiNode &#123; ElemType data; // 数据域 struct BiNode *lchild, *rchild; // 左右孩子指针&#125;BiNode, *BiTree; 线索二叉树的基本概念与性质 基本概念 线索二叉树的实质就是对一个非线性结构进行线性化操作，使在这个访问序列中的每一个节点都有一个直接前驱和一个直接后继，引入线索二叉树是为了加快查找节点前驱和后继的速度。 在有N个节点的二叉树中，一共有N+1空指针。在二叉树线索化的时候，通常规定：若无左子树，另lchild指向其前驱节点；若无右子树，则rchild指向其后继节点。还需要两个标志域ltag和rtag表明当前指针域所指的对象是左子节点还是直接前驱。保标志域的含义如下所示： ltag: 0 lchild域指示节点的左孩子；1 lchild域指示节点的前驱； rtag: 0 rchild域指示节点的右孩子；1 rchild域指示节点的后继。 线索二叉树的存储结构描述如下所示： 12345typedef struct ThreadNode &#123; ElemType data; // 数据域 struct ThreadNode *lchild, *rchild; // 左右孩子指针 int ltag, rtag; // 左右线索标志 &#125; ThreadNode, *TreadTree; 二叉树的操作二叉树的遍历 先序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 12345678910111213141516171819202122232425262728293031 // 递归实现先序遍历二叉树 void PreOrder(BiTree T) &#123; if (T != NULL) &#123; visit(T); PreOrder(T -&gt; lchild); PreOrder(T -&gt; rchild); &#125; &#125;/*非递归实现先序遍历二叉树 算法思路： 需要借助栈来实现，从根节点开始遍历二叉树，如果节点不为空 先输出节点的数据，节点入栈，然后指针指向节点的左孩子，如 果节点为空那么从占中弹出这个节点，并且将指针指向节点的右 孩子，重复这个过程直到栈为空，并且指针指向也为空为止。*/void PreOrder2(BiTree T) &#123; InitStack(S); BiTree p = T; while(p || !isEmpty(S)) &#123; if (p) &#123; visit(p); push(S, p); p = p -&gt; lchild; &#125; else &#123; pop(S, p); p = p -&gt; rchild; &#125; &#125;&#125;// 算法的时间复杂度和空间复杂度都是O(n) 中序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 123456789101112131415161718192021222324252627282930 // 递归算法实现中序遍历二叉树void InOrder(BiTree T) &#123; if (T != NULL) &#123; InOrder(T -&gt; lchild); visit(T); InOrder(T -&gt; rchild); &#125; &#125;/*非递归实现中序遍历二叉树 算法思路： 需要借助栈来实现，从根节点开始遍历二叉树，如果节点不为空 将节点入栈，然后指针指向节点的左孩子，如果节点为空，那么 从栈中弹出这个节点，输出节点的数据，并且将指针指向节点的 右孩子，重复这个过程直到栈为空，并且指针指向也为空为止。*/void InOrder2(BiTree T) &#123; InitStack(S); BiTree p = T; while(p || !isEmpty(S)) &#123; if (p) &#123; push(S, p); p = p -&gt; lchild; &#125; else &#123; pop(S, p); visit(p); p = p -&gt; rchild; &#125; &#125;&#125; 后序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归实现后序遍历二叉树 void PostOrder(BiTree T) &#123; if (T != NULL) &#123; PostOrder(T -&gt; lchild); PostOrder(T -&gt; rchild); visit(T); &#125; &#125;/*非递归实现后序遍历二叉树 算法思想：后序遍历先访问左节点，再访问右节点，最后访问中间节点 在访问到中间节点的时候要先弄清楚是从左节点返回的中间节点还 是从右节点返回的中间节点，所以需要一个辅助指针r指向最近访 问过的节点。*/void PostOrder2(BiTree T) &#123; InitStack(S); BiTree p, r; p = T; r = NULL; while(p || !isEmpty(S)) &#123; if (p) &#123; // 走到最左边 push(S, p); p = p -&gt; lchild; &#125; else &#123; GetTop(S, p); if (p -&gt; rchild &amp;&amp; p -&gt; rchild != r) &#123; // 如果节点的右子树存在，那么转向右边 p = p -&gt; rchild; push(S, p); p = p -&gt; lchild; // 向左走 &#125; else &#123; pop(S, p); visit(p); r = p; p = NULL; //重置指针 &#125; &#125; // else &#125; // while&#125; 层次遍历 1234567891011121314151617181920212223242526272829303132333435363738void LevelOrder(BiTree T) &#123; // 二叉树从上到下，从左到右的层次遍历需要借助队列来实现 InitQueue(Q); BiTree p = NULL; EnQueue(Q, T); // 根节点入栈； while(!isEmpty(Q)) &#123; DeQueue(Q, p); visit(p); if (p -&gt; lchild != NULL) EnQueue(p -&gt; lchild); if (p - &gt; rchild != NULL) EnQueue(p -&gt; rchild); &#125;&#125;void LevelOrderInverse(BiTree T) &#123; // 二叉树从下到上，从右到左的层次遍历 // 实现思路：将二叉树从上到下，左到右的顺序放入栈中， // 等遍历完了再弹出即可 if (T != NULL) &#123; InitStack(S); InitQueue(Q); BiTree p = t; EnQueue(Q, p); // 将根节点放入队列中 while(!isEmpty(Q)) &#123; DeQueue(Q, p); push(S, p); if (p -&gt; lchild) EnQueue(p -&gt; lchild); if (p -&gt; rchild) EnQueue(p -&gt; rchild); &#125; while(!isEmpty(S)) &#123; pop(S, p); visit(p) &#125; &#125;&#125; 由遍历序列构造二叉树（1）根据二叉树的先序和中序可以唯一的确定一棵二叉树： 假设先序和中序分别存在两个一维数组A[1….n],B[1….n]中，编写算法建立该二叉树的二叉链表。1234567891011121314151617181920212223242526/*这个算法需要遍历两个一维数组，递归实现：根据先序序列确定二叉树的根节点，根据根节点，在中序序列中划分出左子树和右子树，递归这个过程。*/BiTree PreInCreat(ElemType A[], ElemType B[], int l1, int h1, int 12, int h2) &#123; // l1,h1分别树先序序列的第一个节点和最后一个节点； // l2,h2分别树中序序列的第一个节点和最后一个节点； BiTree root = (BiNode*)malloc(sizeof(BiNode)); root -&gt; data = A[l1]; int i = 0; for (i = 0; B[i] != A[l1]; i++); // 在中序序列中找到根节点位置 int lenl = i - l2; int lenr = h2 - i; if (lenl) &#123; // 递归建立左子树 root - lchild = PreInCreat(A, B, l1 + 1, l1 + lenl, l2, l2 + lenl - 1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if (lenr) &#123; // 递归建立右子树 root - rchild = PreInCreat(A, B, h1-lenr+1, h1, h2-lenr+1, h2); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125; (2) 由二叉树的后序序列和中序序列可以唯一的确定一棵二叉树假设后序和中序分别存在两个一维数组A[1….n],B[1….n]中，编写算法建立该二叉树的二叉链表。后序序列的最后一个节点和先序序列的第一个节点类似，可以将中序分割成两个子序列。123456789101112131415161718192021222324BiTree PostInCreat(ElemType A[], ElemType B[], int l1, int h1, int l2, int h2) &#123; // l1,h1分别树后序序列的第一个节点和最后一个节点； // l2,h2分别树中序序列的第一个节点和最后一个节点; BiTree root = (BiNode*)malloc(sizeof(BiNode)); root -&gt; data = A[h1]; int i = 0; for(i = 0;B[i] != A[h1]; i++); // 在中序序列里面找到根节点 int lenl = i - l2; int lenr = h2 - i; if(lenl) &#123; root -&gt; lchild = PostInCreat(A, B, l1, l1+lenl-1, l2, l2+lenl-1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if(lenr) &#123; root -&gt; rchild = PostInCreat(A, B, h1-lenr, h1-1, h2-lenr+1, h2); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125;` (3) 由二叉树的层序序列和中序序列也可以唯一的确定一棵二叉树1234567891011121314151617181920212223242526272829303132333435// 假设层序序列和中序分别存在两个一维数组A[1....n], B[1....n]中，// 编写算法建立该二叉树的二叉链表。/* 算法思路：从左到右遍历层序数组，层序遍历的第一个元素如果在中序 中没有访问过，那么这个数可以作为根节点，根据这个根节点可以 将中序序列划分为左子树和右子树。期间需要借助一个数组来记录 元素是否在中序序列中被访问过。*/BiTree LevelInCreat(ElemType A[], ElemType B[], boolean C[], int index, int l, int r) &#123;/* 初始时C是一个全为真的布尔数组，大小与A,B相同，如果C中元素在 B中被访问过，那么标记为假，此时A中对应的被访问到的元素就不能 作为根节点，需要继续往右寻找没有被访问过的节点作为根节点。*/ BiTree root = (BiNode*)malloc(sizeof(BiNode)); for(index; C[index] == false; index++); // 排除已经访问过的节点的干扰 root -&gt; data = A[index]; int i = 0; for(i = 0; B[i] != A[index]; i++); C[index] = false; // 已经访问过的节点就标记为已访问 int lenl = i - l; int lenr = r - i; if (lenl) &#123; root -&gt; lchild = LevelInCreat(A, B, C, index+1, l, l+lenl-1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if(lenr) &#123; root -&gt; lchild = LevelInCreat(A, B, C, index+1, r-lenr+1, r); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125; 一些二叉树的题目 （1）判断二叉树是否为完全二叉树 思路：使用层次遍历算法，将所有节点加入队列，包括空节点，遍历结束 后查看队列，如果遇到了空节点，看看其后是否有非空节点，如果有，那 么二叉树不是完全二叉树，否则是完全二叉树。 （2）链式存储，计算二叉树的所有双分支节点的个数 思路：采用如下所示的递归式： f(b) = 0; 若b = NULL f(b) = f(b-&gt;lchild) + f(b-&gt;rchild) + 1; 若b为双分支节点 f(b) = f(b-&gt;lchild) + f(b-&gt;rchild); 其余情况 （3）交换二叉树中所有节点的左右子树 swap(b-&gt;lchild) 递归交换左子树 swap(b-&gt;rchild) 递归交换右子树 交换左右孩子节点 （4）指针p,q分别指向二叉树的任意两个节点，寻找p,q的最近的公共祖先节点。 采用后序遍历，访问到其中一个节点之后将其之后的所有祖先节点放 入一个队列中，另一个节点也是一样，访问到之后将其所有祖先节点 放入另一个队列中，遍历结束之后，比较两个队列，两个队列第一个 相同的元素就是两个节点的最近公共祖先节点。 （5）链式存储，求非空二叉树的宽度 采用层次遍历即可得出 （6）满二叉树已知先序序列pre，求后序序列post. 先序序列的第一个节点为后序序列的最后一个节点，然后除第一个元 素之外，将先序序列划分为大小相等的两份，再对这两份转化。 void PreToPost(pre, post, int l1, int h1, int l2, int h2) { if(h1 &gt;= l1) { post[h2] = pre[l1]; half = (h1-l1) / 2; PreToPost(pre, post, l1+1, l1+half, l2, l2+half-1); PreToPost(pre, post, l1+half+1, h1, l2+half, h2-1); } }]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树与森林]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[@TOC 树和森林树的基本概念与性质 基本概念 树的定义是递归的，树是一种逻辑结构，同时也是一种分层结构。 性质 （1）树中的节点数等于所有节点的度数加1； （2）度为m的树中第i层上至多有m^(i-1)个节点； （3）高度为h的m叉树至多有(m^h - 1)/(m-1)个节点； （4）具有n个节点的m叉树的最小高度为[logm(n(m-1)+1)] 树的存储结构 （1）双亲表示法 采用一组连续的空间存储每个节点，同时在每个节点中增设一个伪指针，指示这个节点的双亲节点在数组中的位置，利用这种存储结构可以很快的得到每一个节点的双亲节点，但是求节点的孩子节点时需要遍历整个结构。 （2）孩子表示法 每个节点的孩子节点都用一个单链表链接起来形成一个线性结构，那么N个节点就有N个孩子链表。 （3）孩子兄弟表示法 又称为二叉树表示法，即以二叉链表作为树的存储结构，使得每个节点包括三个内容：节点值、指向节点第一个孩子节点的指针和指向节点下一个兄弟节点的指针。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
</search>
