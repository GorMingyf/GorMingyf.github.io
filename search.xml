<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F26%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——内部排序之交换排序内部排序排序的一篇优秀博客 插入排序 折半插入排序 希尔排序（不稳定） 冒泡排序 123456789101112131415161718void BubbleSort(ElemType A[], int n) &#123; int temp = 0; // 标记数组是不是有序的； bool flag = false; for (int i = 0; i &lt; n - 1; i++) &#123; flag = false; for (int j = n - 1; j &gt; i; j--) &#123; if(A[j - 1].key &gt; A[j].key) &#123; temp = A[j - 1].key; A[j - 1].key = A[j].key; A[j].key = temp; flag = true; &#125; &#125; if(flag == false) return; &#125;&#125; 快速排序 1234567891011121314151617181920void QuickSort(ElemType A[], int low, int high) &#123; if (low &lt; high) &#123; int mid = Partion(A, low, high); QuickSort(A, low, mid - 1); QuickSort(A, mid + 1, high); &#125;&#125;int Partion(ElemType A[], int low, int high) &#123; ElemType privot = A[low]; // 将数组的第一个元素设置成枢纽值，对数组进行划分 while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; return low;&#125; 算法练习 线性表按顺序存储，使用最少的时间和空间将所有奇数移动到偶数的前面 123456789101112131415void OddEvenEx(ElemType A[], int n) &#123; int i = 0; int j = n - 1; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; A[j] % 2 != 1) --j; // 从后向前寻找第一个奇数 while(i &lt; j &amp;&amp; A[i] % 2 != 0) ++i; // 从前向后寻找第一个偶数 if (i &lt; j) &#123; Swap(A[i], A[j]); ++i; --j; &#125; &#125;&#125; 试在数组A[1…n]中寻找第k小的数。 1234567891011121314151617181920212223242526272829303132ElemType KthLeast(ElemType A[], int k, int low, int high) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; /*这里使用递归的方式来实现 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; low = low + 1; high = n - 1; &#125; else &#123; high = low - 1; low = 0; &#125; */ //这里的k如果数组下表是从0开始的话，最开始的时候k需要减1 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; // 在后一部分继续寻找 return KthLeast(A, k, low + 1, high_temp); &#125; else &#123; // 在前一部分继续寻找 return KthLeast(A, k, low_temp, low - 1); &#125;&#125; 2016年计算机联考真题 已知由n（n&gt;=2）个正整数构成的集合A ，将其划分成两个不相交的子集A1和A2，元素个数分别为n1和n2，A1和A2中元素之和分别为S1和S2。设计一个尽可能高效的划分算法，满足|n1-n2|最小且|S1-S2|最大。要求： 1）给出算法的基本设计思想。 2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。 3）说明你所设计算法的平均时间复杂度和空间复杂度。 算法解析：这道题目是求第k大的数的一个变种. |n1-n2|最小且|S1-S2|最大，在数组元素为奇数个的时候，|n1-n2|最小为1，那么把前n/2个最小的数放在一个数组，后面n/2+1个比较大的数放在另一个数组，这时得到的结果满足条件；数组元素为偶数个的时候，|n1-n2|最小为0，所以，第一个数组里面的数是比较小的前n/2个数，第二个数组的是后n/2个比较大的数 1234567891011121314151617181920void ArrPartion(ElemType A[], int low, int high, int k) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt; privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt; privot) ++low; A[high] = A[low]; &#125; A[low] = privot; if (low == k) &#123; return; &#125; else if (low &lt; k) &#123; ArrPartion(A, low_temp, low - 1, k); &#125; else &#123; ArrPartion(A, low + 1, high_temp, k); &#125;&#125; 荷兰国旗难题 现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。 算法思想：对线性表从前往后进行扫描，将红色的条块放到前面，蓝色对的条块放到后面，白色的条块自然也就在中间的位置，故而需要三个指针，begin和end分别指向数组的头部和尾部，current指针从前往后扫描，如果遇到红色就和头部进行交换，如果遇到蓝色则和尾部交换。 算法实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef enum&#123;RED, WHITE, BLUE&#125; color;void Holland_Partion(color arr[], int n) &#123; int begin = 0; int end = n - 1; int current = begin; color temp; while(current &lt;= end) &#123; switch(arr[current])&#123; case RED: temp = arr[begin]; arr[begin] = arr[current]; arr[current] = temp; begin++; current++; break; case WHITE: current++; break; case BLUE: temp = arr[end]; arr[end] = arr[current]; arr[current] = temp; end--; // current没有++，因为担心交换后current指向的仍为BLUE &#125; &#125;&#125;int main() &#123; color arr[12]; for(int i = 0; i &lt; 12; i+=3) &#123; arr[i] = WHITE; arr[i + 1] = BLUE; arr[i + 2] = RED; &#125; for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; Holland_Partion(arr, 12); for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F26%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E5%80%BC%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——内部排序之交换排序内部排序排序的一篇优秀博客 插入排序 折半插入排序 希尔排序（不稳定） 冒泡排序 123456789101112131415161718void BubbleSort(ElemType A[], int n) &#123; int temp = 0; // 标记数组是不是有序的； bool flag = false; for (int i = 0; i &lt; n - 1; i++) &#123; flag = false; for (int j = n - 1; j &gt; i; j--) &#123; if(A[j - 1].key &gt; A[j].key) &#123; temp = A[j - 1].key; A[j - 1].key = A[j].key; A[j].key = temp; flag = true; &#125; &#125; if(flag == false) return; &#125;&#125; 快速排序 1234567891011121314151617181920void QuickSort(ElemType A[], int low, int high) &#123; if (low &lt; high) &#123; int mid = Partion(A, low, high); QuickSort(A, low, mid - 1); QuickSort(A, mid + 1, high); &#125;&#125;int Partion(ElemType A[], int low, int high) &#123; ElemType privot = A[low]; // 将数组的第一个元素设置成枢纽值，对数组进行划分 while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; return low;&#125; 算法练习 线性表按顺序存储，使用最少的时间和空间将所有奇数移动到偶数的前面 123456789101112131415void OddEvenEx(ElemType A[], int n) &#123; int i = 0; int j = n - 1; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; A[j] % 2 != 1) --j; // 从后向前寻找第一个奇数 while(i &lt; j &amp;&amp; A[i] % 2 != 0) ++i; // 从前向后寻找第一个偶数 if (i &lt; j) &#123; Swap(A[i], A[j]); ++i; --j; &#125; &#125;&#125; 试在数组A[1…n]中寻找第k小的数。 1234567891011121314151617181920212223242526272829303132ElemType KthLeast(ElemType A[], int k, int low, int high) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; /*这里使用递归的方式来实现 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; low = low + 1; high = n - 1; &#125; else &#123; high = low - 1; low = 0; &#125; */ //这里的k如果数组下表是从0开始的话，最开始的时候k需要减1 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; // 在后一部分继续寻找 return KthLeast(A, k, low + 1, high_temp); &#125; else &#123; // 在前一部分继续寻找 return KthLeast(A, k, low_temp, low - 1); &#125;&#125; 2016年计算机联考真题 已知由n（n&gt;=2）个正整数构成的集合A ，将其划分成两个不相交的子集A1和A2，元素个数分别为n1和n2，A1和A2中元素之和分别为S1和S2。设计一个尽可能高效的划分算法，满足|n1-n2|最小且|S1-S2|最大。要求： 1）给出算法的基本设计思想。 2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。 3）说明你所设计算法的平均时间复杂度和空间复杂度。 算法解析：这道题目是求第k大的数的一个变种. |n1-n2|最小且|S1-S2|最大，在数组元素为奇数个的时候，|n1-n2|最小为1，那么把前n/2个最小的数放在一个数组，后面n/2+1个比较大的数放在另一个数组，这时得到的结果满足条件；数组元素为偶数个的时候，|n1-n2|最小为0，所以，第一个数组里面的数是比较小的前n/2个数，第二个数组的是后n/2个比较大的数 1234567891011121314151617181920void ArrPartion(ElemType A[], int low, int high, int k) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt; privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt; privot) ++low; A[high] = A[low]; &#125; A[low] = privot; if (low == k) &#123; return; &#125; else if (low &lt; k) &#123; ArrPartion(A, low_temp, low - 1, k); &#125; else &#123; ArrPartion(A, low + 1, high_temp, k); &#125;&#125; 荷兰国旗难题 现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。 算法思想：对线性表从前往后进行扫描，将红色的条块放到前面，蓝色对的条块放到后面，白色的条块自然也就在中间的位置，故而需要三个指针，begin和end分别指向数组的头部和尾部，current指针从前往后扫描，如果遇到红色就和头部进行交换，如果遇到蓝色则和尾部交换。 算法实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef enum&#123;RED, WHITE, BLUE&#125; color;void Holland_Partion(color arr[], int n) &#123; int begin = 0; int end = n - 1; int current = begin; color temp; while(current &lt;= end) &#123; switch(arr[current])&#123; case RED: temp = arr[begin]; arr[begin] = arr[current]; arr[current] = temp; begin++; current++; break; case WHITE: current++; break; case BLUE: temp = arr[end]; arr[end] = arr[current]; arr[current] = temp; end--; // current没有++，因为担心交换后current指向的仍为BLUE &#125; &#125;&#125;int main() &#123; color arr[12]; for(int i = 0; i &lt; 12; i+=3) &#123; arr[i] = WHITE; arr[i + 1] = BLUE; arr[i + 2] = RED; &#125; for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; Holland_Partion(arr, 12); for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F25%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——归并排序与基数排序归并排序 归并排序遵循了分治模式，直观上就是分解：分解带排序的元素的序列成各具n/2个元素的两个子序列；解决：使用归并排序递归的排序两个子序列；合并：合并两个已排序的子序列以产生已排序的答案。 首先看看如何合并已排序的两个数组，为了避免在每一个基本步骤都必须检查数组是否已经到了最末端，在两个数组的最末端都放置了哨兵——将两个数组的最末端的元素设置为最大，这样就可以避免对数组的检查： 12345678910111213141516171819202122232425262728int* MergeSort(int* arr, int p, int q, int r) &#123; //the sort interval is arr[p, q] to arr[q + 1, r] int n1 = q - p + 1; int n2 = r - q; int* left = (int*)malloc(sizeof(1) * (n1+1)); int* right = (int*)malloc(sizeof(1) * (n2+1)); for (int i = p; i &lt;= q; i++) left[i-p] = arr[i]; for (int i = q + 1; i &lt;= r; i++) right[i - q - 1] = arr[i]; left[n1] = INT_MAX; right[n2] = INT_MAX; int i = 0; int j = 0; for (int k = p; k &lt;= r; k++) &#123; if (left[i] &lt;= right[j]) &#123; arr[k] = left[i]; i += 1; &#125; else if (left[i] &gt; right[j]) &#123; arr[k] = right[j]; j += 1; &#125; &#125; free(left); free(right); return arr; &#125; 下面使用循环不变式方法来证明这个算法的正确性：初始化：在循环的第一次迭代之前，有k=p,数组arr[p, k - 1]为空，i， j 均为0，说明left[i]和right[j]都是各自所在数组里最小的元素，且这两个元素均没有被复制到arr数组里面；保持：为了更好的理解循环不变式，首先假设left[i] &lt;= right[j]，这时left[i]是最小的没有被复制到数组里的最小的元素，将left[i]复制到数组里面之后数组arr[p…k]包含了k-p-1个最小的元素，然后p 和 i，均加1，为下一次迭代重新建立了循环不变式。终止：循环终止的条件是k=r+1。这个时候数组包含了两个数组的所有元素，且是有序的。综上所述，证明了上述算法的正确性！ 接下来考虑递归算法： 123456789int* Merge(int* arr, int p, int r) &#123; if (p &lt; r) &#123; int q = (p + r) / 2; Merge(arr, p, q); Merge(arr, q + 1, r); MergeSort(arr, p, q, r); &#125; return arr; &#125; 递归算法将一个数组分成两半，分别对这两半进行排序之后，再将这两个排好序的数组组合成为一个数组。 接下来分析归并算法的时间复杂度：每一次都将一个节点划分成为两个，直到所有的节点都被划分成为最小的单位为止，划分的时候会产生log n + 1层，而对于每一层的划分，总的代价都是cn(遍历大数组，产生每一个小数组)，所以递归的总的代价就是cn(log n + 1) ，时间复杂度为 n(log n). 以下是本次在LeetCode上面所做的题目： Sort a linked list in O(n log n) time using constant space complexity.根据上面的分析，程序如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* sortList(struct ListNode* head) &#123; int* MergeSort(int* arr, int p, int q, int r) &#123; //the sort interval is arr[p, q] to arr[q + 1, r] int n1 = q - p + 1; int n2 = r - q; int* left = (int*)malloc(sizeof(1) * (n1+1)); int* right = (int*)malloc(sizeof(1) * (n2+1)); for (int i = p; i &lt;= q; i++) left[i-p] = arr[i]; for (int i = q + 1; i &lt;= r; i++) right[i - q - 1] = arr[i]; left[n1] = INT_MAX; right[n2] = INT_MAX; int i = 0; int j = 0; for (int k = p; k &lt;= r; k++) &#123; if (left[i] &lt;= right[j]) &#123; arr[k] = left[i]; i += 1; &#125; else if (left[i] &gt; right[j]) &#123; arr[k] = right[j]; j += 1; &#125; &#125; free(left); free(right); return arr; &#125; int* Merge(int* arr, int p, int r) &#123; if (p &lt; r) &#123; int q = (p + r) / 2; Merge(arr, p, q); Merge(arr, q + 1, r); MergeSort(arr, p, q, r); &#125; return arr; &#125; int size = 0; struct ListNode* temp = head; while (temp != NULL) &#123; size ++; temp = temp -&gt; next; &#125; if (size &gt; 1) &#123; int* arr1 = (int*)malloc(sizeof(1) * size); size = 0; temp = head; while (temp != NULL) &#123; arr1[size] = temp -&gt; val; size ++; temp = temp -&gt; next; &#125; Merge(arr1, 0, size - 1); temp = head; size = 0; while (temp != NULL) &#123; temp -&gt; val = arr1[size]; size ++; temp = temp -&gt; next; &#125; free(arr1); &#125; return head;&#125; 基数排序]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F25%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——内部排序之选择排序简单选择排序选择排序开始的时候，我们扫描整个列表，找到它的最小元素然后和第一个元素交换，将最小元素放到它在有序表的最终位置上。然后我们从第二个元素开始扫描列表，找到最后n-1个元素的最小元素，再和第二个元素交换位置，把第二小的元素放在它最终的位置上。如此循环下去，在n-1遍以后，列表就排好序了。 算法： 123456789101112void SelectSort(ElemType A[], int n) &#123; int min = 0; for (int i = 0; i &lt; n-1; i++) &#123; min = i; for (int j = i + 1; j &lt; n, j++) &#123; if (A[j] &lt; A[min]) min = j; &#125; if (min != i) Swap(A[i], A[min]); &#125;&#125; 时间复杂度为O(n^2)，空间复杂度为O(1)。 堆排序1. 堆排序简介： 堆排序是一种树形选择排序的方法，它的特点是：在排序过程中，将L[1…n]看成一棵完全二叉树的顺序存储结构，利用完全二叉树的双亲节点和孩子节点的内在关系，在当前无序区中选择关键字最大的元素。 2. 堆的定义为： 堆分为最大堆和最小堆，其实就是完全二叉树。最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子，左右孩子节点之间元素大小不存在大小关系。 3. 基本思想（大根堆）： （1）构造初始堆：是一个反复筛选的过程，n个节点的完全二叉树，最后一个节点是[n/2]个节点的孩子节点，对[n/2]个节点为根的子树进行筛选，使得该子树成为堆，之后一次向前对各节点[n/2-1….1]为根的子树进行筛选，如果不是堆交换后可能会破坏下一级堆，于是继续采用上述方法构造下一级堆，直到以该节点为根的子树构成堆为止，反复利用这个过程直到根节点。 建立大根堆的算法如下所示：123456789101112131415161718192021222324void BuildMaxHeap(ElemType A[], int len) &#123; // 数组下标是从1开始的 for (int i = len/2; i &gt; 0; i--) AdjustDown(A, i, len);&#125;void AdjustDown(ElemType A[], int k, int len) &#123; // 将元素从k往下进行调整 A[0] = A[k]; // A[0]暂存元素 for (int i = 2 * k; i &lt;= len; i *= 2) &#123; // 沿着k较大的子节点向下筛选 if (i &lt; len &amp;&amp; A[i] &lt; A[i+1]) i++; if(A[0] &gt; A[i]) &#123; break; &#125; else &#123; A[k] = A[i]; // 将子节点的元素调整到双亲节点上； k = i; // 从子节点开始继续往下筛选 &#125; &#125; A[i] = A[0];&#125;向下调整的时间与树高度h有关，为O(h)，建堆的过程中每次向下调整时，大部分节点的高度都比较小，因此可以证明在元素为n个的序列上建堆，其时间复杂度为O(n),说明可以在线性时间内建立一个堆。 （2）排序思路：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn)，由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。12345678// 排序算法void HeapSort(ElemType A[], int len) &#123; BuildMaxHeap(A, len); for (int i = len; i &gt; 1; i--) &#123; Swap(A[i], A[1]); // 输出堆顶元素 AdjustDown(A, 1, i-1); // 把剩余的i-1个元素整理成堆。 &#125;&#125; 4. 堆的插入和删除 （1）堆的删除： 由于堆的堆顶元素很有可能是最大的或者是最小的，所以在删除堆顶元素的时候先将堆顶元素与最后一个元素交换，在从堆顶开始向下的调整操作。 （2）堆的插入：堆的插入操作将元素插入到末尾，再对新节点进行向上的调整操作，向上调整的算法如下所示：12345678910void AdjustUp(ElemType A[], int k, int len) &#123; A[0] = A[k]; for (int i = k / 2; i &gt; 0; i = k / 2) &#123; if (A[i] &lt; A[0]) &#123; A[k] = A[i]; k = i; &#125; &#125; A[k] = A[0]&#125; 5. 时空复杂度空间复杂度为O(1), 时间复杂度：建堆时间为O(n)，排序的时候向下调整的时间复杂度为O(h),所以时间复杂度为O(nlogn).堆排序不是稳定的排序算法。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F25%2F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 排序——内部排序之插入排序与交换排序排序的一篇优秀博客 插入排序 插入排序 折半插入排序 希尔排序（不稳定）交换排序 冒泡排序 123456789101112131415161718void BubbleSort(ElemType A[], int n) &#123; int temp = 0; // 标记数组是不是有序的； bool flag = false; for (int i = 0; i &lt; n - 1; i++) &#123; flag = false; for (int j = n - 1; j &gt; i; j--) &#123; if(A[j - 1].key &gt; A[j].key) &#123; temp = A[j - 1].key; A[j - 1].key = A[j].key; A[j].key = temp; flag = true; &#125; &#125; if(flag == false) return; &#125;&#125; 快速排序 1234567891011121314151617181920void QuickSort(ElemType A[], int low, int high) &#123; if (low &lt; high) &#123; int mid = Partion(A, low, high); QuickSort(A, low, mid - 1); QuickSort(A, mid + 1, high); &#125;&#125;int Partion(ElemType A[], int low, int high) &#123; ElemType privot = A[low]; // 将数组的第一个元素设置成枢纽值，对数组进行划分 while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; return low;&#125; 算法练习 线性表按顺序存储，使用最少的时间和空间将所有奇数移动到偶数的前面 借助了快排的思路 123456789101112131415void OddEvenEx(ElemType A[], int n) &#123; int i = 0; int j = n - 1; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; A[j] % 2 != 1) --j; // 从后向前寻找第一个奇数 while(i &lt; j &amp;&amp; A[i] % 2 != 0) ++i; // 从前向后寻找第一个偶数 if (i &lt; j) &#123; Swap(A[i], A[j]); ++i; --j; &#125; &#125;&#125; 试在数组A[1…n]中寻找第k小的数。 借助了快排的思路 1234567891011121314151617181920212223242526272829303132ElemType KthLeast(ElemType A[], int k, int low, int high) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt;= privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt;= privot) ++low; A[high] = A[low]; &#125; A[low] = privot; /*这里使用递归的方式来实现 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; low = low + 1; high = n - 1; &#125; else &#123; high = low - 1; low = 0; &#125; */ //这里的k如果数组下表是从0开始的话，最开始的时候k需要减1 if (low == k) &#123; return A[low]; &#125; else if (low &lt; k) &#123; // 在后一部分继续寻找 return KthLeast(A, k, low + 1, high_temp); &#125; else &#123; // 在前一部分继续寻找 return KthLeast(A, k, low_temp, low - 1); &#125;&#125; 2016年计算机联考真题 已知由n（n&gt;=2）个正整数构成的集合A ，将其划分成两个不相交的子集A1和A2，元素个数分别为n1和n2，A1和A2中元素之和分别为S1和S2。设计一个尽可能高效的划分算法，满足|n1-n2|最小且|S1-S2|最大。要求： 1）给出算法的基本设计思想。 2）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。 3）说明你所设计算法的平均时间复杂度和空间复杂度。 借助了快排的思路 算法解析：这道题目是求第k大的数的一个变种。|n1-n2|最小且|S1-S2|最大，在数组元素为奇数个的时候，|n1-n2|最小为1，那么把前n/2个最小的数放在一个数组，后面n/2+1个比较大的数放在另一个数组，这时得到的结果满足条件；数组元素为偶数个的时候，|n1-n2|最小为0，所以，第一个数组里面的数是比较小的前n/2个数，第二个数组的是后n/2个比较大的数 1234567891011121314151617181920void ArrPartion(ElemType A[], int low, int high, int k) &#123; ElemType privot = A[low]; int low_temp = low; int high_temp = high; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; A[high] &gt; privot) --high; A[low] = A[high]; while(low &lt; high &amp;&amp; A[low] &lt; privot) ++low; A[high] = A[low]; &#125; A[low] = privot; if (low == k) &#123; return; &#125; else if (low &lt; k) &#123; ArrPartion(A, low_temp, low - 1, k); &#125; else &#123; ArrPartion(A, low + 1, high_temp, k); &#125;&#125; 荷兰国旗难题 现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。 算法思想：借助了快排的思路对线性表从前往后进行扫描，将红色的条块放到前面，蓝色对的条块放到后面，白色的条块自然也就在中间的位置，故而需要三个指针，begin和end分别指向数组的头部和尾部，current指针从前往后扫描，如果遇到红色就和头部进行交换，如果遇到蓝色则和尾部交换。 算法实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;typedef enum&#123;RED, WHITE, BLUE&#125; color;void Holland_Partion(color arr[], int n) &#123; int begin = 0; int end = n - 1; int current = begin; color temp; while(current &lt;= end) &#123; switch(arr[current])&#123; case RED: temp = arr[begin]; arr[begin] = arr[current]; arr[current] = temp; begin++; current++; break; case WHITE: current++; break; case BLUE: temp = arr[end]; arr[end] = arr[current]; arr[current] = temp; end--; // current没有++，因为担心交换后 // current指向的仍为BLUE &#125; &#125;&#125;int main() &#123; color arr[12]; for(int i = 0; i &lt; 12; i+=3) &#123; arr[i] = WHITE; arr[i + 1] = BLUE; arr[i + 2] = RED; &#125; for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; Holland_Partion(arr, 12); for(int i = 0; i &lt; 12; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F24%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[@TOC 字符串模式匹配简单的字符串模式匹配算法串的模式匹配是求第一个字符串在第二个字符串中的位置1234567891011121314151617int Index(String str, String t) &#123; // 求字符串t在str中的位置。 // str[0]和t[0]存储的是字符串的长度； int i = 1, j = 1; while(i &lt;= str[0] &amp;&amp; j &lt;= t[0]) &#123; if(str[i] == t[j]) &#123; i++; j++; &#125; else &#123; i = i - j + 2; j = 1; &#125; &#125; if (j &gt; t[0]) return i - t[0]; return 0;&#125; 简单模式匹配算法的时间复杂度为O(m*n)，m和n分别为主串和模式串的长度。 改进的模式匹配算法——KMP算法KMP算法可以在O(m+n)的时间数量级上完成串的模式匹配操作。 1234567891011121314151617181920212223242526272829303132void get_next(char T[], int next[]) &#123; int i = 1; next[1] = 0; // next[0]不使用 int j = 0; while(i &lt;= T[0]) &#123; if (j == 0 || T[i] == T[j]) &#123; ++i; ++j; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125;&#125;int KMP(char S[], char T[], int next[], int pos) &#123; // 求模式串T在主串S中第pos个字符之后的位置的KMP算法 i = pos; j = 1; while(i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123; if(j == 0 || S[i] == T[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; if(j &gt; T[0]) return i - T[0]; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F20%2F%E5%9B%BE%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@TOC 图——存储及遍历图的定义定义：图G是由顶点集V和边集E组成，记为G=(V, E),其中V(G)表示图G的顶点的非空有限集，E(G)表示图中的边的集合。顶点的个数称为图的阶。 基本概念： 有向图 无向图 简单图：如果图满如下条件则图称为简单图：（1）不存在重复边；（2）不存在顶点到自身的边；则称图为简单图。 多重图：若图G中某两个节点之间的边数对于一条，又允许顶点通过同一条边和自己相关联，则称图G为多重图。 完全图（也称简单完全图）：无向图中如果任意两个顶点之间都有一条边相关联，则称图为无向完全图。在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图。 子图 连通，连通图和连通分量：在无向图中，如果顶点v和w之间有路径存在，则称v和w是连通的，若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量，如果图中有n个顶点，并且有小于n-1条边，则此图必是非连通图。 强连通图和强连通分量：在有向图中如果从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。 生成树，生成森林：生成树是包含图中所有顶点的一个极小连通子图，如果图中有n个顶点，则它的生成树含有n-1条边。 顶点的度，入度和出度：在无向图中，顶点的度等于边数的二倍；在有向图中度分为入度和出度，有向图中所有顶点的入度和出度之和都等于边数。 边的权和网：边上带有权值的图称为带权图，也称为网。 稠密图，稀疏图：一般当图G满足：|E| &lt; |V|log(|V|)时，将图看成稀疏图。 路径，路径长度和回路：第一个顶点和最后一个顶点相同的路径称为回路或者环。 简单路径和简单回路：在路径序列中，顶点不重复出现的路径称为简单路径，除第一个顶点和最后一个顶点之外，其余顶点不重复的路径成为简单回路。 距离 有向树：有一个顶点入度为0，其余顶点入度为1的树称为有向树。 图的存储及基本操作图的存储 邻接矩阵法 用一个一位数组存储图中顶点的信息，用一个二维数组存储图中边的信息，存储顶点之间邻接关系的二维数组称为邻接矩阵。 图的邻接矩阵的数据结构定义如下： 12345678#define MaxVertexNum 100 //顶点的最大数目typedef char VertexType; //顶点的数据类型typedef int EdgeType; //带权图上边的权值的数据类型typedef struct &#123; VertexType Vex[MaxVertexNum] //顶点表 EdgeType Edge[MaxVertexNum][MaxVertexNum] //边表 int vexnum, edgenum; //当前顶点数和边数&#125;MGraph; 稠密图适合邻接矩阵法。 邻接表法 对图中的每一个节点建立一个单链表。顶点表节点由节点域(data)和指向第一条邻接边的指针firstarc构成，边表由邻接节点域adjvex和指向下一条邻接边的指针域nextarc构成。 图的邻接表的数据结构定义如下： 123456789101112131415#define MaxVertexNum 100typedef struct ArcNode &#123; // 边表节点 int adjvex; // 该弧指向的节点的顶点的位置 struct ArcNode* nextarc; // 指向下一条弧的指针&#125; ArcNode;typedef struct VNode &#123; //顶点表节点。 int data; struct VNode* firstarc;&#125; VNode, AdjList[MaxVertexNum];typedef struct &#123; AdjList vnode; // 邻接表 int vernum, arcnum;&#125; ALGraph; 十字链表在十字链表中很容易找到vi为结尾的弧，和以vi为头的弧。 邻接多重表 图的基本操作 判断图G是否存在无向边&lt;v, w&gt;或有向边(v, w); 列出图G中与x邻接的边； 在图G中插入顶点x； 在图G中删除顶点x； 如果无向边&lt;v, w&gt;或有向边(v, w)不存在则插入； 如果无向边&lt;v, w&gt;或有向边(v, w)存在，则删除此边； 求图G中顶点x的第一个邻接点； 获取图G中无向边&lt;v, w&gt;或有向边(v, w)对应的权值； 设置图G中无向边&lt;v, w&gt;或有向边(v, w)的权值。 图的遍历广度优先搜索BFS广度优先搜索需要借助一个队列来实现 1. 伪代码表示如下所示：123456789101112131415161718192021222324252627282930bool visited[MAX_VERTEX_NUM];void BFSTraverse(Graph G) &#123; for(int i = 0; i &lt; G.vexnum, i++) visited[i] = false; for(int i = 0; i &lt; G.vexnum, i++) if(!visited[i]) BFS(G, i);&#125;void BFS(Graph G, int v) &#123; // 从顶点v出发，广度优先遍历图G，算法借助一个辅助队列Q visit(v); visited[v] = true; InitQueue(Q); EnQueue(Q, v); while(!isEmpty(Q)) &#123; DeQueue(Q, u); for(int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) &#123; // w = NextNeighbor(G, u, w)这个函数的意思 // 是返回除w以外的顶点u的下一个邻接顶点 if(!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w); &#125; &#125; &#125;&#125; 2. 算法性能分析 （1）如果图的存储方式是邻接矩阵存储的话，那么在广度优先遍历的时候每个顶点都需要搜索一次（入队一次），故而时间复杂度是O(|V|)，在搜索任意一个定点的邻接顶点的时候每一条边都会至少搜索一次，所以时间复杂度为O(|E|)，算法总的时间复杂度为O(|V|+|E|)； （2）如果图的存储方式是矩阵存储的话，查找每个顶点需要O(|V|)的是时间复杂度，所以算法的总的时间复杂度是O(|V|^2). 3. BFS算法求解单源最短路径问题 使用BFS，可以求解一个非带权图的单源最短路径。 伪代码表示如下所示：1234567891011121314151617181920212223void BFS(Graph G, int u) &#123; // 从顶点v出发，广度优先遍历图G，算法借助一个辅助队列Q // d[i]表示从u到i的最短路径的长度。 for (int i = 0; i &lt; G.vexnum, i++) d[i] = MAX_INT; visited[u] = true; d[u] = 0; InitQueue(Q); EnQueue(Q, u); while(!isEmpty(Q)) &#123; DeQueue(Q, u); for(int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) &#123; // w = NextNeighbor(G, u, w)这个函数的意思 // 是返回除w以外的顶点u的下一个邻接顶点 if(!visited[w]) &#123; d[w] = d[u] + 1; visited[w] = true; EnQueue(Q, w); &#125; &#125; &#125; &#125; 4. 广度优先生成树在广度优先遍历的过程中，可以得到一棵遍历树，称为广度优先遍历树，树的邻接矩阵的存储是唯一的，所以邻接矩阵存储方式下得到的优先树也是唯一的，树的邻接矩阵存储不是唯一的，所以广度优先树也是不唯一的。 深度优先搜索DFS深度优先搜索基本思想：首先访问图中的某一个顶点u，然后访问与u邻接且未被访问的任一顶点v，在访问与v邻接的任一未被访问的顶点w….依次下去直到不能再往下走了，然后返回到最近未被访问的顶点，若它还有邻接顶点未被访问过，则从改点开始继续上述的搜索过程，直到图中所有顶点都被访问过为止。1. 算法的伪代码表示如下所示：1234567891011121314151617bool visited[MAX_VERTEX_NUM];void DFSTraverse(Graph G) &#123; for(int i = 0; i &lt; G.vexnum, i++) visited[i] = false; for(int i = 0; i &lt; G.vexnum, i++) if(!visited[i]) DFS(G, i);&#125;void DFS(Graph G, int u) &#123; // 采用递归的思路实现广度优先搜索。 visit(u); visited[u] = true; for(int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) if(!visited[w]) DFS(G, w);&#125; 2. 算法性能分析 这个算法采用递归的思路，需要借助递归工作栈，所以它的空间复杂度为O(|V|),邻接矩阵存储时算法时间复杂度为O(|V|^2)，使用邻接矩阵存储时，算法的时间复杂度为O(|V| + |E|)。 3. 深度优先树和生成森林 对连通图DFS产生深度优先生成树，否则产生的将是深度优先生成树林。 图的遍历与连通性对于无向图，如果无向图是连通的，那么遍历一次就能够访问图中的所有节点，若无向图是非连通的，那么每一次遍历只能遍历一个连通分量的所有顶点；对于有向图来说，如果从顶点开始到图的每一个顶点都有路径，则能够访问到图中的所有顶点，否则不能。 算法演练 写出从图的邻接表表示转换成邻接矩阵表示的算法。 12345678910void Convert(ALGraph&amp; G, int arc[M][M]) &#123; VNode* p = NULL; for(int i = 0; i &lt; M; i++) &#123; p = (G -&gt; vnode[i]).firstarc; // 取出顶点i的第一条边 while(p) &#123; // 遍历链表 arc[i][p -&gt; adjvex] = 1; p = p -&gt; nextarc; &#125; &#125;&#125; 设计一个算法，判断一个无向图G是否是一颗树，如果是返回true，否则返回false 123456789101112131415161718192021222324// 算法思路：无向连通图的判断条件是无回路的连通图或者有n-1条边的连通图。这里使用有n-1条边的连通图来作为判断条件bool IsTree(Graph G) &#123; bool visited[MAX_VERTES_NUM]; for(int i = 0; i &lt; G.vernum; i++) visited[i] = false; int vnum = 0, enum = 0; DFS(G, 0, vnum, enum, visited); if(vnum == G.vernum &amp;&amp; enum == (G.vernum - 1)) return true; return false;&#125;void DFS(Graph G, int v, int vnum, int enum, bool visited[]) &#123; visited[v] = true; vnum++; int w = FirstNeighbor(G, v); while(w != -1) &#123; enum++; if(!visited[w]) DFS(G, w, vnum, enum, visited); w = NextNeighbor(G, v, w); &#125;&#125; 图G采用邻接表形式存储，请写出图遍历的非递归深度优先搜索算法。首先看一下图的邻接表形式存储的数据结构： 12345678910#define MaxVertexNum 100typedef struct VNode &#123; //顶点表节点。 int data; struct VNode* nextarc;&#125; VNode, AdjList[MaxVertexNum];typedef struct &#123; AdjList vnode; // 邻接表 int vernum, arcnum;&#125; ALGraph; 算法如下：借助栈来实现回退bool visited[MAX_VERTEX_NUM]; void NRur_DFS(Graph G, int u) { InitStack(sta); for(int i = 0; i &lt; G.vernum; i++) visited[i] = false; Push(sta, u); visited[u] = true; while(!isEmpty(sta)) { Pop(sta, p); visit(p); for(int w = FirstNeighbor(G, p); w &gt;= 0; w = NextNeighbor(G, p, w)) { if(!visited[w]) { Push(sta, w); visted[w] = true; } } }}123456789101112131. 分别使用深度优先搜索和广度优先搜索遍历算法，判别以邻接表方式存储的有向图中是否存在由定点u到定点v的路径。 邻接表形式的图的数据结构如下： ```C++ #define MaxVertexNum 100 typedef struct VNode &#123; //顶点表节点。 int data; struct VNode* nextarc; &#125; VNode, AdjList[MaxVertexNum]; typedef struct &#123; AdjList vnode; // 邻接表 int vernum, arcnum; &#125; ALGraph; BFS:12345678910111213141516171819202122232425bool visited[MaxVertexNum];void BFSPath(Graph G, int u, int v) &#123; for(int i = 0; i &lt; G.vernum; i++) visited[i] = false; return BFS_Path(G, u, v);&#125;bool BFS_Path(Graph G, int u, int v) &#123; visited[u] = true; InitQueue(Q); EnQueue(Q, u); while(!isEmpty(Q)) &#123; DeQueue(Q, u); for(int w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) &#123; if(!visited[w]) &#123; visited[w] = true; EnQueue(Q, u); if(w == v) return true; &#125; &#125; &#125; return false;&#125; DFS:bool visited[MaxVertexNum];void DFSPath(Graph G, int u, int v) { for(int i = 0; i &lt; G.vernum; i++) visited[i] = false; return DFS_Path(G, u, v);}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F20%2F%E5%9B%BE%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC 图——应用图广度优先遍历可以判断一个图是否为连通图；广度优先遍历可以求得非带权图的单源最短路径。 最小生成树 Prim算法 Prim算法的时间复杂度为O(|V|^2)，不依赖于|E|，故而适用于求解稠密图的最小生成树。 Kruskal算法 这个算法是按照权值递增的顺序选择合适的边来构造生成树。时间复杂度是O(|E|log|E|) 最短路径 Dijkstra算法求解带权图的单源最短路径问题 Floyd-Warshall算法求解带权图的任意两个顶点之间的最短路径问题 拓扑排序关键路径]]></content>
  </entry>
  <entry>
    <title><![CDATA[树与森林]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[@TOC 树和森林树的基本概念与性质 基本概念 树的定义是递归的，树是一种逻辑结构，同时也是一种分层结构。 性质 （1）树中的节点数等于所有节点的度数加1； （2）度为m的树中第i层上至多有m^(i-1)个节点； （3）高度为h的m叉树至多有(m^h - 1)/(m-1)个节点； （4）具有n个节点的m叉树的最小高度为[logm(n(m-1)+1)] 树的存储结构 （1）双亲表示法 采用一组连续的空间存储每个节点，同时在每个节点中增设一个伪指针，指示这个节点的双亲节点在数组中的位置，利用这种存储结构可以很快的得到每一个节点的双亲节点，但是求节点的孩子节点时需要遍历整个结构。 （2）孩子表示法 每个节点的孩子节点都用一个单链表链接起来形成一个线性结构，那么N个节点就有N个孩子链表。 （3）孩子兄弟表示法 又称为二叉树表示法，即以二叉链表作为树的存储结构，使得每个节点包括三个内容：节点值、指向节点第一个孩子节点的指针和指向节点下一个兄弟节点的指针。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的概念与操作]]></title>
    <url>%2F2018%2F12%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@[TOC]目录 二叉树——概念与操作基本概念二叉树的基本概念与性质 基本概念 二叉树有5种基本形态，特殊的二叉树有满二叉树、完全二叉树、二叉排序树和平衡二叉树。 性质 存储结构 二叉树的存储结构有顺序存储结构和链式存储结构两种。满二叉树和完全二叉树采取顺序存储结构比较合适，树中的节点号可以唯一的反映出节点之间的逻辑关系，可以节省空间也可以利用数组元素的下标确定节点在二叉树中的位置以及节点之间的关系。一般二叉树采用链式结构存储，二叉链表中包含3个域，分别是数据域data、左指针lchild和右指针rchild。二叉树的链式存储结构描述如下：12345// 二叉树链式存储结构typedef struct BiNode &#123; ElemType data; // 数据域 struct BiNode *lchild, *rchild; // 左右孩子指针&#125;BiNode, *BiTree; 线索二叉树的基本概念与性质 基本概念 线索二叉树的实质就是对一个非线性结构进行线性化操作，使在这个访问序列中的每一个节点都有一个直接前驱和一个直接后继，引入线索二叉树是为了加快查找节点前驱和后继的速度。 在有N个节点的二叉树中，一共有N+1空指针。在二叉树线索化的时候，通常规定：若无左子树，另lchild指向其前驱节点；若无右子树，则rchild指向其后继节点。还需要两个标志域ltag和rtag表明当前指针域所指的对象是左子节点还是直接前驱。保标志域的含义如下所示： ltag: 0 lchild域指示节点的左孩子；1 lchild域指示节点的前驱； rtag: 0 rchild域指示节点的右孩子；1 rchild域指示节点的后继。 线索二叉树的存储结构描述如下所示： 12345typedef struct ThreadNode &#123; ElemType data; // 数据域 struct ThreadNode *lchild, *rchild; // 左右孩子指针 int ltag, rtag; // 左右线索标志 &#125; ThreadNode, *TreadTree; 二叉树的操作二叉树的遍历 先序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 12345678910111213141516171819202122232425262728293031 // 递归实现先序遍历二叉树 void PreOrder(BiTree T) &#123; if (T != NULL) &#123; visit(T); PreOrder(T -&gt; lchild); PreOrder(T -&gt; rchild); &#125; &#125;/*非递归实现先序遍历二叉树 算法思路： 需要借助栈来实现，从根节点开始遍历二叉树，如果节点不为空 先输出节点的数据，节点入栈，然后指针指向节点的左孩子，如 果节点为空那么从占中弹出这个节点，并且将指针指向节点的右 孩子，重复这个过程直到栈为空，并且指针指向也为空为止。*/void PreOrder2(BiTree T) &#123; InitStack(S); BiTree p = T; while(p || !isEmpty(S)) &#123; if (p) &#123; visit(p); push(S, p); p = p -&gt; lchild; &#125; else &#123; pop(S, p); p = p -&gt; rchild; &#125; &#125;&#125;// 算法的时间复杂度和空间复杂度都是O(n) 中序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 123456789101112131415161718192021222324252627282930 // 递归算法实现中序遍历二叉树void InOrder(BiTree T) &#123; if (T != NULL) &#123; InOrder(T -&gt; lchild); visit(T); InOrder(T -&gt; rchild); &#125; &#125;/*非递归实现中序遍历二叉树 算法思路： 需要借助栈来实现，从根节点开始遍历二叉树，如果节点不为空 将节点入栈，然后指针指向节点的左孩子，如果节点为空，那么 从栈中弹出这个节点，输出节点的数据，并且将指针指向节点的 右孩子，重复这个过程直到栈为空，并且指针指向也为空为止。*/void InOrder2(BiTree T) &#123; InitStack(S); BiTree p = T; while(p || !isEmpty(S)) &#123; if (p) &#123; push(S, p); p = p -&gt; lchild; &#125; else &#123; pop(S, p); visit(p); p = p -&gt; rchild; &#125; &#125;&#125; 后序遍历由于这种算法每一个节点都访问且仅访问一次，所以算法的时间复杂度为O(n),在最坏的情况下，算法的空间复杂度为O(n). 12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归实现后序遍历二叉树 void PostOrder(BiTree T) &#123; if (T != NULL) &#123; PostOrder(T -&gt; lchild); PostOrder(T -&gt; rchild); visit(T); &#125; &#125;/*非递归实现后序遍历二叉树 算法思想：后序遍历先访问左节点，再访问右节点，最后访问中间节点 在访问到中间节点的时候要先弄清楚是从左节点返回的中间节点还 是从右节点返回的中间节点，所以需要一个辅助指针r指向最近访 问过的节点。*/void PostOrder2(BiTree T) &#123; InitStack(S); BiTree p, r; p = T; r = NULL; while(p || !isEmpty(S)) &#123; if (p) &#123; // 走到最左边 push(S, p); p = p -&gt; lchild; &#125; else &#123; GetTop(S, p); if (p -&gt; rchild &amp;&amp; p -&gt; rchild != r) &#123; // 如果节点的右子树存在，那么转向右边 p = p -&gt; rchild; push(S, p); p = p -&gt; lchild; // 向左走 &#125; else &#123; pop(S, p); visit(p); r = p; p = NULL; //重置指针 &#125; &#125; // else &#125; // while&#125; 层次遍历 1234567891011121314151617181920212223242526272829303132333435363738void LevelOrder(BiTree T) &#123; // 二叉树从上到下，从左到右的层次遍历需要借助队列来实现 InitQueue(Q); BiTree p = NULL; EnQueue(Q, T); // 根节点入栈； while(!isEmpty(Q)) &#123; DeQueue(Q, p); visit(p); if (p -&gt; lchild != NULL) EnQueue(p -&gt; lchild); if (p - &gt; rchild != NULL) EnQueue(p -&gt; rchild); &#125;&#125;void LevelOrderInverse(BiTree T) &#123; // 二叉树从下到上，从右到左的层次遍历 // 实现思路：将二叉树从上到下，左到右的顺序放入栈中， // 等遍历完了再弹出即可 if (T != NULL) &#123; InitStack(S); InitQueue(Q); BiTree p = t; EnQueue(Q, p); // 将根节点放入队列中 while(!isEmpty(Q)) &#123; DeQueue(Q, p); push(S, p); if (p -&gt; lchild) EnQueue(p -&gt; lchild); if (p -&gt; rchild) EnQueue(p -&gt; rchild); &#125; while(!isEmpty(S)) &#123; pop(S, p); visit(p) &#125; &#125;&#125; 由遍历序列构造二叉树（1）根据二叉树的先序和中序可以唯一的确定一棵二叉树： 假设先序和中序分别存在两个一维数组A[1….n],B[1….n]中，编写算法建立该二叉树的二叉链表。1234567891011121314151617181920212223242526/*这个算法需要遍历两个一维数组，递归实现：根据先序序列确定二叉树的根节点，根据根节点，在中序序列中划分出左子树和右子树，递归这个过程。*/BiTree PreInCreat(ElemType A[], ElemType B[], int l1, int h1, int 12, int h2) &#123; // l1,h1分别树先序序列的第一个节点和最后一个节点； // l2,h2分别树中序序列的第一个节点和最后一个节点； BiTree root = (BiNode*)malloc(sizeof(BiNode)); root -&gt; data = A[l1]; int i = 0; for (i = 0; B[i] != A[l1]; i++); // 在中序序列中找到根节点位置 int lenl = i - l2; int lenr = h2 - i; if (lenl) &#123; // 递归建立左子树 root - lchild = PreInCreat(A, B, l1 + 1, l1 + lenl, l2, l2 + lenl - 1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if (lenr) &#123; // 递归建立右子树 root - rchild = PreInCreat(A, B, h1-lenr+1, h1, h2-lenr+1, h2); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125; (2) 由二叉树的后序序列和中序序列可以唯一的确定一棵二叉树假设后序和中序分别存在两个一维数组A[1….n],B[1….n]中，编写算法建立该二叉树的二叉链表。后序序列的最后一个节点和先序序列的第一个节点类似，可以将中序分割成两个子序列。123456789101112131415161718192021222324BiTree PostInCreat(ElemType A[], ElemType B[], int l1, int h1, int l2, int h2) &#123; // l1,h1分别树后序序列的第一个节点和最后一个节点； // l2,h2分别树中序序列的第一个节点和最后一个节点; BiTree root = (BiNode*)malloc(sizeof(BiNode)); root -&gt; data = A[h1]; int i = 0; for(i = 0;B[i] != A[h1]; i++); // 在中序序列里面找到根节点 int lenl = i - l2; int lenr = h2 - i; if(lenl) &#123; root -&gt; lchild = PostInCreat(A, B, l1, l1+lenl-1, l2, l2+lenl-1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if(lenr) &#123; root -&gt; rchild = PostInCreat(A, B, h1-lenr, h1-1, h2-lenr+1, h2); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125;` (3) 由二叉树的层序序列和中序序列也可以唯一的确定一棵二叉树1234567891011121314151617181920212223242526272829303132333435// 假设层序序列和中序分别存在两个一维数组A[1....n], B[1....n]中，// 编写算法建立该二叉树的二叉链表。/* 算法思路：从左到右遍历层序数组，层序遍历的第一个元素如果在中序 中没有访问过，那么这个数可以作为根节点，根据这个根节点可以 将中序序列划分为左子树和右子树。期间需要借助一个数组来记录 元素是否在中序序列中被访问过。*/BiTree LevelInCreat(ElemType A[], ElemType B[], boolean C[], int index, int l, int r) &#123;/* 初始时C是一个全为真的布尔数组，大小与A,B相同，如果C中元素在 B中被访问过，那么标记为假，此时A中对应的被访问到的元素就不能 作为根节点，需要继续往右寻找没有被访问过的节点作为根节点。*/ BiTree root = (BiNode*)malloc(sizeof(BiNode)); for(index; C[index] == false; index++); // 排除已经访问过的节点的干扰 root -&gt; data = A[index]; int i = 0; for(i = 0; B[i] != A[index]; i++); C[index] = false; // 已经访问过的节点就标记为已访问 int lenl = i - l; int lenr = r - i; if (lenl) &#123; root -&gt; lchild = LevelInCreat(A, B, C, index+1, l, l+lenl-1); &#125; else &#123; root -&gt; lchild = NULL; &#125; if(lenr) &#123; root -&gt; lchild = LevelInCreat(A, B, C, index+1, r-lenr+1, r); &#125; else &#123; root -&gt; rchild = NULL; &#125; return root;&#125; 一些二叉树的题目 （1）判断二叉树是否为完全二叉树 思路：使用层次遍历算法，将所有节点加入队列，包括空节点，遍历结束 后查看队列，如果遇到了空节点，看看其后是否有非空节点，如果有，那 么二叉树不是完全二叉树，否则是完全二叉树。 （2）链式存储，计算二叉树的所有双分支节点的个数 思路：采用如下所示的递归式： f(b) = 0; 若b = NULL f(b) = f(b-&gt;lchild) + f(b-&gt;rchild) + 1; 若b为双分支节点 f(b) = f(b-&gt;lchild) + f(b-&gt;rchild); 其余情况 （3）交换二叉树中所有节点的左右子树 swap(b-&gt;lchild) 递归交换左子树 swap(b-&gt;rchild) 递归交换右子树 交换左右孩子节点 （4）指针p,q分别指向二叉树的任意两个节点，寻找p,q的最近的公共祖先节点。 采用后序遍历，访问到其中一个节点之后将其之后的所有祖先节点放 入一个队列中，另一个节点也是一样，访问到之后将其所有祖先节点 放入另一个队列中，遍历结束之后，比较两个队列，两个队列第一个 相同的元素就是两个节点的最近公共祖先节点。 （5）链式存储，求非空二叉树的宽度 采用层次遍历即可得出 （6）满二叉树已知先序序列pre，求后序序列post. 先序序列的第一个节点为后序序列的最后一个节点，然后除第一个元 素之外，将先序序列划分为大小相等的两份，再对这两份转化。 void PreToPost(pre, post, int l1, int h1, int l2, int h2) { if(h1 &gt;= l1) { post[h2] = pre[l1]; half = (h1-l1) / 2; PreToPost(pre, post, l1+1, l1+half, l2, l2+half-1); PreToPost(pre, post, l1+half+1, h1, l2+half, h2-1); } }]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的应用]]></title>
    <url>%2F2018%2F12%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC 二叉树——应用二叉排序树（BST） 二叉排序树的定义 或者是一棵空树，或者有如下性质的树： （1）若左子树非空，则左子树上所有节点关键字值均小于根节点的关键字值；（2）若右子树非空，则右子树上所有节点关键字值均大于根节点的关键字值；（3）左右子树也分别是一颗二叉排序树。因此，对二叉排序树的中序遍历得到的就是一个递增的序列。 二叉排序树的查找 从根节点开始，沿一个分支逐层向下进行比较的过程。若二叉树非空，将给定的关键字与根节点的值比较，如果相同则查找成功，如果不相同，如果给定的关键字的值大于根节点的值那么转向右子树寻找，如果小于则向左子树寻找。 算法表示如下所示： 1234567891011121314151617181920212223242526BSTNode* BST_Search(BiTree T, ElemType key, BSTNode *p) &#123; // 查找函数返回指向关键字值为key的节点指针，如果不存在， // 返回NULL // p指向被查找节点的双亲节点 p = NULL; while(T &amp;&amp; key != T-&gt;data) &#123; p = T; if (key &lt; T -&gt; data) T = T -&gt; lchild; else T = T -&gt; rchild; &#125; return T;&#125;BSTNode* BST_RecurSearch(BiTree T, ElemType key, BSTNode *p) &#123; // 算法的递归实现形式 if (T) &#123; if (key == T -&gt; data) return T; else if (key &lt; T -&gt; data) BST_RecurSearch(T -&gt; lchild, key, T) else BST_RecurSearch(T -&gt; rchild, key, T) &#125;&#125; 二叉排序树的插入在查找的过程中，如果没有查找到关键字值的二叉树时，将节点插入到二叉树中，如果二叉树原本为空则要插入的节点为根节点，如果要插入的值比根节点的值大则插入到右子树中，如果比根节点的值小，则插入到左子树中。 算法如下所示： 12345678910111213141516int BST_Insert(BiTree &amp;T, ElemType key) &#123; // 如果二叉树中存在值为key的节点，那么返回0； // 如果二叉树中不存在值为key的节点，那么插入节点并返回1； if (T == NULL) &#123; T = (BSTNode*)malloc(sizeof(BSTNode)); T -&gt; data = key; T -&gt; lchild = T -&gt; rchild = NULL; return 1; &#125; else if (T -&gt; data == key) &#123; return 0; &#125; else if (key &lt; T -&gt; data) &#123; BST_Insert(T -&gt; lchild, key); &#125; else &#123; BST_Insert(T -&gt; rchild, key); &#125;&#125; 二叉排序树的构造 依次输入数据元素，并且将它们插入到排序树中适当的位置。具体过程是每读入一个元素就建立一个新节点，若二叉树为空则这个节点为根节点，如果二叉树不为空的话，则将这个节点插入二叉树中。 算法如下所示： 12345678void BST_Creat(BiTree &amp;T, ElemType str[], int n) &#123; T == NULL; int i = 0; while(i &lt; n) &#123; BST_Insert(T, str[i]); i++; &#125;&#125; 二叉排序树的删除 删除二叉树节点的过程按照三种情况来处理： （1）如果被删除节点是叶子结点，则直接删除，不会破坏二叉排序树的性质； （2）如果节点只有一颗左子树或者右子树，则让节点的子树称为节点父节点的子树，代替被删除节点的位置； （3）如果被删除节点有左右子树的话，则在右子树中找中序第一个子女填补。 算法表示如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void BST_Delete(BiTree T, ElemType key) &#123; BiTree pre = NULL; BiTree p = BST_Search(T, key, pre); // 查找节点 if (p == NULL) return; if (p -&gt; lchild == NULL &amp;&amp; p -&gt; rchild == NULL) &#123; // 如果是叶子节点则直接删除； if (pre -&gt; lchild == p) pre -&gt; lchild = NULL; else if (pre -&gt; rchild == p) pre -&gt; rchild = NULL; free(p) &#125; else if (p -&gt; lchild == NULL &amp;&amp; p -&gt; rchild != NULL) &#123; // 左子树为空 if (pre -&gt; lchild == p) pre -&gt; lchild = p -&gt; rchild; else if (pre -&gt; rchild == p) pre -&gt; lchild == p -&gt; rchild; free(p) &#125; else if (p -&gt; lchild != NULL &amp;&amp; p -&gt; rchild == NULL) &#123; // 右子树为空 if (pre -&gt; lchild == p) pre -&gt; lchild == p -&gt; lchild; else if (pre -&gt; rchild == p) pre -&gt; rchild = p -&gt; lchild; free(p); &#125; else &#123; // 左右子树都不为空 // 寻找右子树在中序遍历的情况下第一个输出的节点； BiTree temp = p -&gt; rchild; Bitree pre2 = p; while (temp -&gt; lchild != NULL) &#123; temp = temp -&gt; lchild; pre2 = p; &#125; p -&gt; data = temp -&gt; data; // 删除temp节点； if (pre2 -&gt; lchild == temp) pre2 -&gt; lchild == temp -&gt; rchild; if (pre2 -&gt; rchild == temp) pre2 -&gt; rchild == temp -&gt; rchild; free(temp); &#125;&#125; 二叉平衡树（AVL） 平衡二叉树的定义 在插入和删除节点的时候，保证任意节点的左右子树的高度差不超过1，这样的二叉树称为平衡二叉树，简称平衡树。定义左子树和右子树的高度差为平衡因子，则平衡因子的值只可能为-1， 0， 1三种。 所以平衡二叉树可定义为它或者是一颗空树，或者它的左右子树都是平衡二叉树，并且左右子树的高度差不超过1. 平衡二叉树的插入 按照二叉排序树插入节点的规则向二叉树中插入一个节点，插入之后，如果二叉树不再是平衡二叉树那么调整二叉树，使得这个二叉树成为新的平衡二叉树。 失去平衡之后调整可归纳为一下四种情况： （1）LL平衡旋转：在A节点的左孩子（L）的左子树（L）上插入了新节点，导致A的平衡因子从1变成了2，导致以A为根的子树失去平衡，需要一次向右旋转的操作。使得A的左孩子接替A，而A的左孩子的右子节点称为旋转后的A的左孩子节点。 （2）RR平衡旋转：由于在A节点的右孩子（R）的右子树（R）上插入了新的节点，导致A的平衡因子从-1变成了-2，失去平衡。需要一次向左旋转的操作。 （3）LR平衡旋转：在A节点的左孩子（L）的右子树（R）上插入了新节点，导致A的平衡因子从1变成了2，导致以A为根的子树失去平衡，需要两次旋转，先向左旋转，再向右旋转。 （4）RL平衡旋转：在A节点的右孩子（R）的左子树（L）上插入了新节点，导致A的平衡因子从-1变成了-2，导致以A为根的子树失去平衡，需要两次旋转，先右旋转，再左旋转。 平衡二叉树的查找 查找过程与二叉排序树相同。 关于平衡二叉树的具体实现C++程序，可以参考平衡二叉树详解（本地测试过了，程序可以运行） 哈夫曼树与哈弗曼编码 哈夫曼树的定义 在含有N个带权叶子结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也成为最优二叉树。 哈夫曼树的构造 给定N个权值分别为w1, w2, …, Wn的节点。构造哈夫曼树的算法描述如下： （1）将这N个结点分别作为N棵树仅含一个结点的二叉树，构成森林F. （2）构造一个新节点，并从F中选取两棵根结点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根结点的权 值之和。 （3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 （4）重复步骤2和3，直至F中只剩下一棵树为止。 哈弗曼编码 哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码，它是可变长度编码。可变长编码即可以对待处理字符串中不同字符使用不等长的二进制位表示，可变长编码比固定长度编码好很多，可以对频率高的字符赋予短编码，而对频率较低的字符则赋予较长一些的编码，从而可以使平均编码长度减短，起到压缩数据的效果。 哈夫曼编码是前缀编码。如果没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。对前缀编码的解码也是相对简单的，因为没有一个码是另一个编码的前缀，所以可以识别出第一个编码，将它翻译为原码，再对余下的编码文件重复同样操作。 哈夫曼编码首先要构造一棵哈夫曼树，首先，将每个出现的字符当做一个独立的结点，其权值作为它出现的频度（或次数），然后构造哈夫曼树。显然所有字符节点均出现在叶子结点中。我们可以将字符的编码解释为从根至该字符路径上标记的序列，其中标记为0表示”转向左孩子”，标记为1表示为”转向右孩子”。 部分题目算法编写 判断一棵二叉树是否是二叉排序树。 123456789101112131415161718// 方案1：直接在二叉树中比较 bool isBST_Tree(BiTree T) &#123; if (T) &#123; // 左子值大于根节点值 if (T -&gt; lchild &amp;&amp; T -&gt; lchild -&gt; data &gt; T -&gt; data) return false; // 右子值小于根节点值 if (T -&gt; rchild &amp;&amp; T -&gt; rchild -&gt; data &lt; T -&gt; data) return false; // 不存在左右节点 if (T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL) return true; else return isBST_Tree(T -&gt; lchild) &amp;&amp; isBST_Tree(T -&gt; rchild); &#125; &#125; // 方案2：中序遍历二叉树，得到的结果始终满足前一个元素的数据小于后一个元素的数据。 利用二叉树的遍历思想，判断一棵二叉树是否为平衡二叉树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 void Judge_AVL(BiTree T, int &amp;balance, int &amp;h) &#123; // 左右子树的平衡标记和高度 int bl = 0, br = 0, hl = 0, hr = 0; if (T == NULL) &#123; h = 0; balance = 1; &#125; else if (T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL) &#123; h = 1; balance = 1; &#125; else &#123; Judge_AVL(T -&gt; lchild, bl, hl); Judge_AVL(T -&gt; rchild, br, hr); int h = (hl&gt;hr?hl:hr) + 1; if (abs(h) &lt; 2) balance = bl &amp;&amp; br; else balance = 0; &#125; &#125; ``` 3. 设计一个算法，从大到小输出二叉排序树中所有其值不小于k的关键字。 ```C++ void printk(BiTree T, int k) &#123; if (T) &#123; if (T -&gt; data &gt; k) &#123; printk(T -&gt; rchild, k); cout &lt;&lt; T -&gt; data &lt;&lt; " "; printk(T -&gt; lchild, k); &#125; else if (T -&gt; data == k)&#123; cout &lt;&lt; k &lt;&lt; " "; return; &#125; else &#123; return; &#125; &#125; &#125; // 以下的是一个更为简洁的函数； void Printk(BiTree T, int k) &#123; if (T == NULL) return; if (T -&gt; rchild != NULL) Printk(T -&gt; rchild, k); if (T -&gt; data &gt;= k) cout &lt;&lt; T-&gt; data &lt;&lt; " "; if (T -&gt; lchild != NULL) Printk(t -&gt; lchild, k); &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
